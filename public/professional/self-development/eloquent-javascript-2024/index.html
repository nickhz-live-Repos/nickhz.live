<!DOCTYPE html>

<html>
    <head>
        <!-- <base href="../../../" /> -->
        <link rel="shortcut icon" type="image/x-icon" href="../../../img/nh-cursive-icon.png" />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

        <!-- Page properties -->
        <title>Eloquent JavaScript 2024 - Self-Study - Nick Hernandez</title>

        <!-- Opengraph properties, for giving a site preview if the link is posted anywhere. Makes the link look less sketchy. -->
        <meta property="og:title" content="Eloquent JavaScript 2024 - Self-Study - Nick Hernandez" />
        <meta property="og:description" content="My page for tracking my self-study from the textbook Eloquent JavaScript, 4th Edition, by Marijn Haverbeke" />
        <meta property="og:type" content="website" />
        <meta property="og:image" content="https://nickhz.live/img/built-from-scratch.png" />
        <meta property="og:image:alt" content="built from scratch" />
        <meta property="og:url" content="https://nickhz.live/professional/self-development/eloquent-javascript-2024" />
        <meta property="og:site_name" content="The Personal Site of Nick Hernandez" />

        <!-- Style properties -->
        <link href="../../../css/style.css" rel="stylesheet" />
        <link href="style.css" rel="stylesheet" />
    </head>
    <body>
        <a href="../?a=html-css-js&b=eloquent-javascript-2024" id="back-link">
            &lt; <span class="desktop-only">MY </span>SKILLS<span class="desktop-only"> PAGE</span>
        </a>

        <hgroup id="top">
            <h2>
                Self-Study of 
            </h2>
            <h1>
                Eloquent JavaScript, 4th ed. (2024)
            </h1>
            <h2>
                Textbook by Marijn Haverbeke
            </h2>
            <h4>
                Self-study by Nicolas Hernandez
            </h4>
            <h4>
                <a href="https://eloquentjavascript.net/" target="_blank">Full textbook made available online by the author</a>
            </h4>
        </hgroup>

        <main>
            <details id="preamble">
                <summary>
                    Preamble
                </summary>

                <p>
                    This is a self-study effort from January 2025. Scripts 
                    I wrote for the applicable chapter exercises are at the 
                    bottom of 
                    <a href="https://github.com/Hernandezn/nickhz.live/blob/main/public/professional/self-development/eloquent-javascript-2024/index.html" target="_blank">this 
                    page's source code</a>.
                </p>
                    
                <p>
                    I've been eying this textbook for a few days now, but 
                    since I have this website, I figure this is a good place 
                    to host my notes in an environment where I can actually 
                    execute JavaScript. I didn't have a place to put it, 
                    though, so I changed my site structure to add 
                    <a href="../../" target="_blank">supporting</a> 
                    <a href="../?a=html-css-js&b=eloquent-javascript-2024" target="_blank">pages</a> 
                    that lead to this one.
                </p>

                <p>
                    All this just to start studying? Yes. I enjoy the content 
                    of the work and the learning involved, plus an investment 
                    in myself pays dividends in the future. What kind of fool 
                    works without being told? One who's curious or creative or 
                    future focused or otherwise self-driven... that kind of 
                    fool! And now, I'll fool around with the content of this 
                    book. 
                </p>

                <figure>
                    <img src="../../../img/eloquent-javascript-by-marijn-haverbeke-4th-edition.jpg" alt="Eloquent JavaScript, 4th Edition, by Marijn Haverbeke" height="300" />
                    <figcaption>
                        This page is themed after the cover of the book.
                    </figcaption>
                </figure>
            </details>

            <hr />

            <details id="introduction">
                <summary>
                    Chapter 0 - Introduction
                </summary>

                <blockquote>
                    "A sense of what a good program looks like is developed with practice, not learned from a list of rules."
                </blockquote>

                <p>
                    This chapter discusses very basic concepts on the what & 
                    why of programming & JavaScript, so the part that shines 
                    out to me is the above quote. The author isn't teaching 
                    from a place of telling you what should be done, but 
                    rather from preparing you to tell <i>yourself</i> what 
                    should be done.
                </p>

                <p>
                    One who's not an artist doesn't know the rules. A good 
                    artist knows the rules well and follows them well. A great 
                    artist knows the rules well... and breaks them. Not by 
                    simply ignoring them, but by deconstructing the very 
                    reasons those rules exist.
                </p>

                <p>
                    The author and I share some values. That's what I've 
                    learned from this book's introduction.
                </p>
            </details>

            <hr />

            <details id="chapter-1">
                <summary>
                    Chapter 1 - Values, Types, and Operators
                </summary>

                <blockquote>
                    That's not a bug, it's a feature.
                </blockquote>

                <p>
                    This chapter had lots of basic operations, plus the 
                    nullish operator ("??"), which browsers didn't even widely 
                    support until 2020. I'm not sure a great number of people 
                    formally educated until just recently would even know 
                    about it if they're not doing occasional reviews of the 
                    base technology like I'm doing here. Even then, lots of 
                    documentation was made before this was well-supported. 
                    It's a case where the latest textbook edition is necessary 
                    if it's to supply this knowledge. Sure enough, 
                    <a href="https://eloquentjavascript.net/3rd_edition/01_values.html" target="_blank">this 
                    feature isn't in the same textbook's previous edition</a>. 
                </p>

                <p>
                    These are some concepts from this chapter that I haven't 
                    been using in my JavaScript:
                </p>

                <ul>
                    <li>
                        <code>2.998e8</code> // yields 299800000
                    </li>
                    <li>
                        <code><var>x</var> = <var>a</var> && <var>b</var>;</code> // "guard operator" where a is not boolean; only gives b if a is truthy, and gives back the falsey a otherwise
                    </li>
                    <li>
                        <code><var>x</var> = <var>a</var> || <var>b</var>;</code> // "default operator" where a is not boolean; gives a if it's truthy, and gives the default value b otherwise
                    </li>
                    <li>
                        <code><var>x</var> = <var>a</var> ?? <var>b</var>;</code> // "nullish coalescing operator" where a is not boolean; gives a if it's not null or undefined (so can give falsey a values like 0 or ""), and gives the default value b otherwise
                    </li>
                    <li>
                        <code>NaN != NaN</code>
                    </li>
                </ul>

                <p>
                    Here are some concepts I know that supplement this 
                    chapter: 
                </p>

                <ul>
                    <li>
                        <code>+'5' + 1 === 6 //</code> plus sign as a unary operator explicitly coerces a string to a number, though it's not as complete as parseInt('5'), as +'5px' would instead yield NaN
                    </li>
                    <li>
                        <code>!!'5' === true; !!{} === true; !!0 === false;</code> // double exclamation point as a unary operator explicitly coerces any value to a boolean
                    </li>
                    <li>
                        <code>!'5' === false; !{} === false; !0 === true;</code> // single exclamation point as a unary operator explicitly converts any value to its opposite boolean
                    </li>
                    <li>
                        <code>299_800_000</code> // yields 299800000; underscores can be added in any numeric literals to make them more readable
                    </li>
                </ul>

                <p>
                    Between these two lists, some of them are maybe not 
                    intended by the language, but they're all consistent 
                    enough to be used as outright features.
                </p>
            </details>

            <hr />

            <details id="chapter-2">
                <summary>
                    Chapter 2 - Program Structure
                </summary>

                <blockquote>
                    The devil's in the details.
                </blockquote>

                <p>
                    I already knew everything that was in this chapter, or at 
                    least, I knew everything it intended for me to know. Of 
                    the (offhand-mentioned) list of reserved keywords, I 
                    haven't been using most of the object-oriented ones in my 
                    JavaScript. The keywords <code>async</code> and 
                    <code>await</code> are conspicuously missing from the 
                    chapter's list of keywords, and I don't think I've ever 
                    used the keywords <code>with</code> or <code>yield</code>. 
                    None of this is in the intended scope of the chapter, but 
                    if I'm brushing up on my JavaScript, I think it's good to 
                    look out for places where I can be thorough.
                </p>

                <p>
                    The <code>with</code> keyword is deprecated, but here's 
                    my first script using <code>yield</code>. The below 
                    elements generate a number between the lower & upper 
                    bounds, then stops generating after 10 yields, unless you 
                    change the bounds: 
                    <br />
                    <br />
                    
                    <label for="yield-test-min">Lower Bound:</label>
                    <input type="number" id="yield-test-min" placeholder="min" onchange="refreshYieldTestGenerator()" />
                    <br />
                    <label for="yield-test-max">Upper Bound:</label>
                    <input type="number" id="yield-test-max" placeholder="max" onchange="refreshYieldTestGenerator()" />
                    <br />
                    <button onclick="yieldTestButtonPress()">Yield a value!</button>
                    <br />
                    <br />
                    <span id="yield-test-output" style="border: 1px solid black; padding: 4px;">
                        [press the button to 
                        <code>yield</code> a value from a generator 
                        function]
                    </span>
                    <script>
                        const yieldTestMin = document.getElementById('yield-test-min');
                        const yieldTestMax = document.getElementById('yield-test-max');
                        const yieldTestOutput = document.getElementById('yield-test-output');

                        // generates a random number between min and max
                        const yieldTestGeneratorFunction = function*(min, max) {
                            const diff = max - min;
                            let counter = 0;

                            while(counter++ < 10) {
                                yield min + diff * Math.random();
                            }
                            yield '10 yields reached!';
                        };

                        // refreshes the generator function reference
                        let yieldTestGeneratorIterator = yieldTestGeneratorFunction(0, 0);
                        const refreshYieldTestGenerator = () => {
                            const minInput = +yieldTestMin.value;
                            const maxInput = +yieldTestMax.value;

                            // accounts for missing inputs and maxes lower than mins
                            const min = isNaN(minInput) ? 0 : minInput;
                            const max = isNaN(maxInput) ? min : maxInput < min ? min : maxInput;

                            yieldTestGeneratorIterator = yieldTestGeneratorFunction(min, max);
                        }

                        const yieldTestButtonPress = () => {
                            yieldTestOutput.innerText = yieldTestGeneratorIterator.next().value ?? 'Change the bounds at least once every 10 yields!';
                        };
                    </script>
                </p>

                <h2>
                    Chapter 2 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 2.1 - Looping a Triangle
                            </summary>
                            <code id="exercise-2-1"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 2.2 - FizzBuzz
                            </summary>

                            <code id="exercise-2-2"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 2.3 - Chessboard
                            </summary>

                            <label for="exercise-2-3-input">Select a chessboard size (max 100):</label>
                            <input type="number" id="exercise-2-3-input" value="8" min="0" max="100" increment="1" placeholder="chessboard size" />
                            <br />
                            <br />
                            <code id="exercise-2-3"></code>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-3">
                <summary>
                    Chapter 3 - Functions
                </summary>

                <blockquote>
                    Every instruction is made of smaller instructions, every 
                    little bit's got a million bits.
                </blockquote>

                <p>
                    These chapters are getting longer now. There's a little 
                    quirk to be found in a chapter that instructs how to write 
                    sets of instructions, while part of that instruction is an 
                    example specifically about recursion.
                </p>
                
                <p>
                    The book doesn't specifically endorse one way or the 
                    other when it comes to creating functions, but I'm bought 
                    in on the arrow functions. I always thought that unless 
                    two functions must reference one another, it's bad form to 
                    use a function before it's defined in the code. So I 
                    didn't use this quirk of <code>function fun() {}</code> 
                    declaration notation and wound up forgetting about it. 
                    Plus, this notation never lets you define <code>fun</code> 
                    as a constant, and I always define functions as 
                    <code>const</code> whenever possible. <code>const fun = () 
                    => {}</code> is valid JavaScript, and <code>const function 
                    fun() {}</code> is not.
                </p>

                <p>
                    I should also note that I'd forgotten about default 
                    function inputs that replace undefined ones, where a 
                    function is defined <code>(a, b = 'default input') => 
                    {}</code> so that if a function call is missing an 
                    argument, it can fill <code>b</code> in with the 
                    assignment expression in the function arguments 
                    definition. 
                </p>

                <h2>
                    Chapter 3 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 3.1 - Minimum
                            </summary>

                            <label for="exercise-3-1-input-1">First number:</label>
                            <br />
                            <input type="number" id="exercise-3-1-input-1" value="0" placeholder="First number" />
                            <br />
                            <br />
                            <label for="exercise-3-1-input-2">Second number:</label>
                            <br />
                            <input type="number" id="exercise-3-1-input-2" value="0" placeholder="Second number" />
                            <br />
                            <br />
                            Their minimum: <code id="exercise-3-1"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 3.2 - Recursion
                            </summary>

                            <label for="exercise-3-2-input">Number to check for parity:</label>
                            <br />
                            <input type="number" id="exercise-3-2-input" value="0" placeholder="Second number" />
                            <br />
                            <br />
                            Even or odd? <code id="exercise-3-2"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 3.3 - Bean Counting
                            </summary>

                            <label for="exercise-3-3-input-1">Text to count characters in:</label>
                            <br />
                            <input type="text" id="exercise-3-3-input-1" placeholder="Text to check" />
                            <br />
                            <br />
                            <label for="exercise-3-3-input-2">Character to count for countChar:</label>
                            <br />
                            <input type="text" id="exercise-3-3-input-2" value="B" maxlength="1" placeholder="Character to count" />
                            <br />
                            <br />
                            CountBs: <code id="exercise-3-3-1"></code>
                            <br />
                            CountChar: <code id="exercise-3-3-2"></code>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-4">
                <summary>
                    Chapter 4 - Data Structures: Objects and Arrays
                </summary>

                <blockquote>
                    This is the longest chapter in the book!
                </blockquote>

                <p>
                    Sure enough, my ability with objects in JavaScript has 
                    been pretty under-utilized. In fact, I probably learned 
                    things in the wrong order the first time around, because I 
                    never use the <code>in</code> or <code>delete</code> 
                    keywords, because I didn't understand them when I first 
                    learned about them, because I wasn't using JavaScript 
                    objects until later on! So here's another list of things I 
                    haven't been using in my JavaScript:
                </p>

                <ul>
                    <li>
                        <code>for(const keyName in object) { ... }</code> // for-in loops iterate over the keys in an object 
                    </li>
                    <li>
                        <code>const obj = {a, b}</code> // gives the keys "a" and "b" to an object and assigns them the corresponding values 
                    </li>
                    <li>
                        <code>obj['2']; obj['two words']; {"two words": 2, "fun()": 'yay'}</code> // can assign object keys using otherwise invalid variable names, by using quotes 
                    </li>
                    <li>
                        <code>delete obj.a</code> // removes a key from an object 
                    </li>
                    <li>
                        <code>Object.assign(a, b, c, ...)</code> // merges objects, copying all properties from later objects into the first object 
                    </li>
                    <li>
                        <code>arr[-2]; arr['three']</code> // arrays can have any key because they're just objects; I think it's bad form, but it's good to know 
                    </li>
                    <li>
                        <code>arr.includes('somevalue', num)</code> // checks if an array has a given value at or above the index number num 
                    </li>
                    <li>
                        <code>'somekey' in obj</code> // returns a boolean representing whether some keyname is in the object 
                    </li>
                    <li>
                        <code>let array2 = array1.slice()</code> // slice an array without arguments to just return a new independent copy of the array
                    </li>
                    <li>
                        <code>str.padStart(8, "0")</code> // pads a string; if this string is not 8 characters long, leading 0s are added until it is
                    </li>
                    <li>
                        <code>arr.join(' - ')</code> // joins all elements of an array into a single string, with the argument being added between each entry; [1, 2, 3] -> 1 - 2 - 3
                    </li>
                    <li>
                        <code>let array2 = ['a', ...array1, 'z']</code> // puts all elements from array1 into array2, between the 'a' and 'z' values
                    </li>
                    <li>
                        <code>([a, b, c, d]) => {...}</code> // assigns values from an input array to the values of the variables a, b, c, and d; more wieldy than just using the array
                    </li>
                    <li>
                        <code>JSON.stringify({}); JSON.parse(someJsonString);</code> // converts to and from JSON strings, largely for API calls
                    </li>
                    <li>
                        <code>arr?.[0]; obj?.fun?.()</code> // the winking elvis operator's notation for arrays & function calls
                    </li>
                    <li>
                        <code>n => ({prop: n})</code> // shorthand for an arrow function that returns an object; parentheses keep object from being interpreted as a function body
                    </li>
                </ul>

                <p>
                    In spite of the increasing verbosity of the chapters, I 
                    know some things would remain a complete mystery for an 
                    actual beginner reading this book. In the "Destructuring" 
                    section, it says you can use square brackets to "look 
                    inside" of an array value to bind its contents, but it 
                    doesn't give an example, making this a nearly 
                    indecipherable remark if you don't see an example 
                    (<code>let [a, b, c, d] = someArrayWith4Elements</code>).
                </p>

                <p>
                    The chapter had a bit of math, too, which is cool. It 
                    sometimes takes lots of math & working out general 
                    formulas to make my scripts act the way I want them to, so 
                    seeing someone else using math as part of their process is 
                    refreshing. That's surprisingly uncommon for what 
                    programming fundamentally is.
                </p>

                <h2>
                    Chapter 4 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 4.1 - The Sum of a Range
                            </summary>

                            <label for="exercise-4-1-input-1">Range Start:</label>
                            <br />
                            <input type="number" id="exercise-4-1-input-1" value="1" step="1" />
                            <br />
                            <br />
                            <label for="exercise-4-1-input-2">Range End:</label>
                            <br />
                            <input type="number" id="exercise-4-1-input-2" value="10" step="1" />
                            <br />
                            <br />
                            <label for="exercise-4-1-input-3">Range Step:</label>
                            <br />
                            <input type="number" id="exercise-4-1-input-3" step="1" />
                            <br />
                            <br />
                            Range values: <code id="exercise-4-1-1"></code>
                            <br />
                            Sum of the range: <code id="exercise-4-1-2"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 4.2 - Reversing an Array
                            </summary>

                            <label for="exercise-4-2-input">Array as JSON:</label>
                            <br />
                            <input type="text" id="exercise-4-2-input" value="[&quot;A&quot;, 3, true, &quot;+ -&quot;, 0]" />
                            <br />
                            <br />
                            Reversed array:<br /><code id="exercise-4-2-1"></code>
                            <br />
                            <br />
                            Array before in-place reversal:<br /><code id="exercise-4-2-2"></code>
                            <br />
                            <br />
                            Array after in-place reversal:<br /><code id="exercise-4-2-3"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 4.3 - A List
                            </summary>

                            <label for="exercise-4-3-input-1">Array as JSON:</label>
                            <br />
                            <input type="text" id="exercise-4-3-input-1" value="[&quot;A&quot;, 3, true, &quot;+ -&quot;, null]" />
                            <br />
                            <br />
                            <label for="exercise-4-3-input-2">N (for finding Nth element from list):</label>
                            <br />
                            <input type="number" id="exercise-4-3-input-2" value="0" min="0" step="1" />
                            <br />
                            <br />
                            List constructed from array:<br /><code id="exercise-4-3-1"></code>
                            <br />
                            <br />
                            Array reconstructed from list:<br /><code id="exercise-4-3-2"></code>
                            <br />
                            <br />
                            Nth element from the list:<br /><code id="exercise-4-3-3"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 4.4 - Deep Comparison
                            </summary>

                            <label for="exercise-4-4-input-1">Object 1 as JSON:</label>
                            <br />
                            <input type="text" id="exercise-4-4-input-1" value="{&quot;here&quot;: {&quot;is&quot;: &quot;an&quot;}, &quot;object&quot;: 2}" />
                            <br />
                            <br />
                            <label for="exercise-4-4-input-2">Object 2 as JSON:</label>
                            <br />
                            <input type="text" id="exercise-4-4-input-2" value="{&quot;here&quot;: {}, &quot;object&quot;: 2}" />
                            <br />
                            <br />
                            Are they deeply equal? <code id="exercise-4-4"></code>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-5">
                <summary>
                    Chapter 5 - Higher-order Functions
                </summary>

                <blockquote>
                    Yo, dawg, I heard you like functions.
                </blockquote>

                <p>
                    Well, I looked ahead and saw that chaper 4 was the longest 
                    chapter in the entire book. This chapter was significantly 
                    shorter, though it also covers inbuilt language specifics 
                    that are wheels I've tended to reinvent rather than using 
                    their implementations that are available by default. 
                    Hopefully by having run by these here, I'll have better 
                    recall when it comes time to use them:
                </p>

                <ul>
                    <li>
                        <code>filteredArray = array.filter(item => { return boolean; })</code> // array function to filter out items that return falsey when passed to the given function
                    </li>
                    <li>
                        <code>mappedArray = array.map(item => { return doStuff(item); })</code> // array function to process each item into a value derived from that item, then return those derived values in an array
                    </li>
                    <li>
                        <code>value = array.reduce((item1, item2) => { return combinedItem; }, startItem?)</code> // array function that combines the first value with each subsequent value, using the combining function, iteratively until they're all combined, returning the combination
                    </li>
                    <li>
                        <code>array.some(arg => { return boolean; })</code> // array function returning true if ANY of its values return truthy when passed into the given function
                    </li>
                    <li>
                        <code>array.find( item => { return boolean; } )</code> // array function finding the first element that returns true when it's passed to the given function
                    </li>
                    <li>
                        <code>(a, {b}) => { ... }</code> // asserts that b is a property of an object and uses that property by its value when it's in the function
                    </li>
                </ul>

                <h2>
                    Chapter 5 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 5.1 - Flattening
                            </summary>

                            <label for="exercise-5-1-input">2+ Dimensional Array as JSON:</label>
                            <br />
                            <input type="text" id="exercise-5-1-input" value="[[&quot;A&quot;, 3], [-1, true, &quot;+ -&quot;], [null]]" />
                            <br />
                            <br />
                            Flattened array: <code id="exercise-5-1"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 5.2 - Your Own Loop
                            </summary>

                            <p>
                                This exercise is disabled on the live page. 
                                Below is my solution; it can be pasted in the 
                                code area in the "Your Own Loop" section 
                                <a href="https://eloquentjavascript.net/05_higher_order.html#i-gKQ1S54F4o" target="_blank">here 
                                on the textbook site</a>.
                            </p>

                            <pre>const loop = (value, test, update, body) => {
    let i = value;

    while(test(i)) {
        body(i);
        i = update(i);

        console.log(i);
        console.log(output1.innerText);
    }

    return i;
};

loop(3, n => n > 0, n => n - 1, console.log);
// → 3
// → 2
// → 1
</pre>
                            <!-- Loop output: <code id="exercise-5-2"></code> -->
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 5.3 - Everything
                            </summary>

                            <p>
                                Any exercise whose input would require 
                                arbitrary function definitions won't be 
                                allowed to run off of UI elements on the live 
                                site. My solution below can be checked by 
                                pasting it into the code section under the 
                                "Everything" header 
                                <a href="https://eloquentjavascript.net/05_higher_order.html#i-SmbRSAd5GA" target="_blank">here 
                                on the textbook site</a>.
                            </p>

                            <pre>const every = (arr, test) => {
    for(const item of arr) {
        if(!test(item)) {
            return false;
        }
    }

    return true;
}

console.log(every([1, 3, 5], n => n &lt; 10));
// → true
console.log(every([2, 4, 16], n => n &lt; 10));
// → false
console.log(every([], n => n &lt; 10));
// → true
</pre>

                            <!-- <code id="exercise-"></code> -->
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 5.4 - Dominant Writing Direction
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                Eloquent JavaScript site. My solution is below 
                                and can be pasted & run on the code section 
                                near the bottom of 
                                <a href="https://eloquentjavascript.net/05_higher_order.html#i-4ccl4J1nOw" target="_blank">this 
                                page</a>.
                            </p>

                            <pre>const dominantDirection = (text) => 
    countBy(text, n => characterScript(n.codePointAt(0)))
    .filter(n => n.name != null)
    .reduce((a, b) => a.count > b.count ? a : b)
    .name
    .direction
;
console.log(dominantDirection("Hello!"));
// → ltr
console.log(dominantDirection("Hey, مساء الخير"));
// → rtl
</pre>
                            <!-- <code id="exercise-"></code> -->
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-6">
                <summary>
                    Chapter 6 - The Secret Life of Objects
                </summary>

                <blockquote>
                    It's short for "classification."
                </blockquote>

                <p>
                    There's something so arcane about the Symbol type. When a 
                    Symbol is instantiated, I imagine a unique glyph appearing 
                    and being used as the label for whatever property it 
                    corresponds to.
                </p>

                <p>
                    This chapter had more tinkering with objects, so here are 
                    some more concepts I haven't been using in my code:
                </p>

                <ul>
                    <li>
                        <code>const fun = () => { console.log(this) }; const a = {fun}, b = {fun}; a.fun(); b.fun();</code> // the "this" keyword in functions binds dynamically to any object that uses the function as a method
                    </li>
                    <li>
                        <code>const fun = (property) => { console.log(this[property]) }; fun.call(obj, fun);</code> // "this" can also be dynamically bound by using an object in the function's "call" method
                    </li>
                    <li>
                        <code>const obj = { fun(arg) { return () => { return this[arg] } } };</code> // shorthand java-like object method assignment, and "this" is usable in ARROW functions defined in the method (not "function fun()"" declarations)
                    </li>
                    <li>
                        <code>Object.getPrototypeOf(obj)</code> // returns the prototype of an object, which is like a parent object it's extending; obj always has access to all properties of its prototype, even if obj itself is empty
                    </li>
                    <li>
                        <code>let obj2 = Object.create(obj1);</code> // creates an empty obj2 that has access to all the properties of obj1; Object.getPrototypeOf(obj2) will return obj1
                    </li>
                    <li>
                        <code>"function constructObj(arg) {const obj2 = Object.create(obj); obj2.instanceProperty = arg; return obj2;}" ~= "class Obj {constructor(arg) {this.instanceProperty = arg} classProperty: }"</code> // class instead of prototype as an object's template; its prototype only any methods defined in the class
                    </li>
                    <li>
                        // a class is fundamentally just a function with a .prototype property where it references methods added to the class, with the new keyword doing the work to make objects invoked with the constructor contain the methods in .prototype; was confusing me until I read <a href="https://stackoverflow.com/a/38972040" target="_blank">this rundown</a>
                    </li>
                    <li>
                        // only non-arrow functions have the .prototype property, which is why only arrow functions work well with "this" bindings when they're defined within a class method's body
                    </li>
                    <li>
                        <code>const SomeClass = class { ... }</code> // constant class name binding declaration
                    </li>
                    <li>
                        <code>let obj = new class { log() { console.log(this) } }; obj.log();</code> // object declaration as an instance of an anonymous class
                    </li>
                    <li>
                        <code>class { #secretField = 3; #secretMethod() { console.log('this can only be called from inside the class') } publicMethod() { this.#secretMethod(); } }</code> // a class can have private properties by starting their names with #
                    </li>
                    <li>
                        // private properties MUST be declared within the class; only public properties can be assigned to the class or object instance after the class is defined
                    </li>
                    <li>
                        <code>SomeClass.prototype.property2 = 'new property';</code> // property2 becomes visible in all objects that are instances of SomeClass
                    </li>
                    <li>
                        <code>SomeClass.prototype.method2 = function() { console.log(this); };</code> // for adding new methods to the prototype, it's best to use the function keyword instead of an arrow function, so that any "this" instances don't bind to the global scope
                    </li>
                    <li>
                        <code>const pureObject = Object.create(null);</code> // creates an object with no prototype; only has what you define without inheriting any properties from Object.prototype
                    </li>
                    <li>
                        <code>Object.keys(obj);</code> // note that it does not return its prototype's values, only the object's own values
                    </li>
                    <li>
                        <code>let a = Symbol(2); let obj = { a: 2, [a]: 'symbol property', b: 4}; obj.a === 2; obj[a] === 'symbol property';</code> // can define a symbol as an object property name by giving it square brackets in the object definition declaration
                    </li>
                    <li>
                        <code>class { static fun() { new this() } }</code> // classes can have static methods that are class members instead of instance members, and new this() calls the constructor of the class where it's contained
                    </li>
                    <li>
                        <code>class IterableThing{ constructor(){} [Symbol.iterator]() { return new class ThingIterator{ constructor(){} next() { return {value, done} } } } }</code> // <a href="https://eloquentjavascript.net/06_object.html#h-z2tOOXM8qO" target="_blank">iterator interface</a>; makes the class objects usable for a for-of loop and for the destructuring operator ("...thing")
                    </li>
                    <li>
                        <code>static staticProperty = 'some value'; static staticMethod() { return this.staticProperty }</code> // static methods can access static properties with the this keyword, as the object instance is the class constructor in this context
                    </li>
                </ul>

                <p>
                    I already knew about maps, the "extends" & "static" & 
                    "super" keywords work like in Java. The syntax is similar, 
                    but you can tell that all things about JavaScript classes 
                    are syntactic construct made by composing objects & 
                    functions such that they can look & act like Java classes, 
                    with the syntax hiding all of the complexity required for 
                    that underneath. It's not a fundamental of the language 
                    like it is in Java; it's a bunch of other concepts all 
                    coming together to make this, which makes it harder to 
                    wrap your head around, despite the code itself being 
                    mostly familiar.
                </p>

                <h2>
                    Chapter 6 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 6.1 - A Vector Type
                            </summary>

                            <p>
                                Vector 1:
                            </p>
                            <label for="exercise-6-1-input-1">X:</label> 
                            <input type="number" id="exercise-6-1-input-1" value="8" />
                            <label for="exercise-6-1-input-2">Y:</label> 
                            <input type="number" id="exercise-6-1-input-2" value="15" />
                            <br />
                            <br />
                            <p>
                                Vector 2:
                            </p>
                            <label for="exercise-6-1-input-3">X:</label> 
                            <input type="number" id="exercise-6-1-input-3" value="3" />
                            <label for="exercise-6-1-input-4">Y:</label> 
                            <input type="number" id="exercise-6-1-input-4" value="4" />
                            <br />
                            <br />
                            Vector 1 + Vector 2: <code id="exercise-6-1-1"></code>
                            <br />
                            <br />
                            Vector 1 - Vector 2: <code id="exercise-6-1-2"></code>
                            <br />
                            <br />
                            Vector 1 length: <code id="exercise-6-1-3"></code>
                            <br />
                            <br />
                            Vector 2 length: <code id="exercise-6-1-4"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 6.2 - Groups
                            </summary>

                            <label for="exercise-6-2-input-1">Create New Group Using this Array (as JSON):</label>
                            <br />
                            <input type="text" id="exercise-6-2-input-1" value="[&quot;10&quot;, &quot;20&quot;]" />
                            <br />
                            <br />
                            Add this value to the group: <input type="text" id="exercise-6-2-input-2" placeholder="value to add" /><input type="button" id="exercise-6-2-input-3" value="Add to Group" />
                            <br />
                            <br />
                            Delete this value from the group: <input type="text" id="exercise-6-2-input-4" placeholder="value to remove" /><input type="button" id="exercise-6-2-input-5" value="Delete from Group" />
                            <br />
                            <br />
                            Check if the group has this value: <input type="text" id="exercise-6-2-input-6" value="10" />
                            <br />
                            Does the group have the above value? <code id="exercise-6-2">Yes</code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 6.3 - Iterable Groups
                            </summary>

                            <label for="exercise-6-3-input-1">Create New Group Using this Array (as JSON):</label>
                            <br />
                            <input type="text" id="exercise-6-3-input-1" value="[&quot;10&quot;, &quot;20&quot;]" />
                            <br />
                            <br />
                            Add this value to the group: <input type="text" id="exercise-6-3-input-2" placeholder="value to add" /><input type="button" id="exercise-6-3-input-3" value="Add to Group" />
                            <br />
                            <br />
                            Delete this value from the group: <input type="text" id="exercise-6-3-input-4" placeholder="value to remove" /><input type="button" id="exercise-6-3-input-5" value="Delete from Group" />
                            <br />
                            <br />
                            Check if the group has this value: <input type="text" id="exercise-6-3-input-6" value="10" />
                            <br />
                            Does the group have the above value? <code id="exercise-6-3-1">Yes</code>
                            <br />
                            <br />
                            Iterative printout of values in this Group:
                            <br />
                            <code id="exercise-6-3-2"></code>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-7">
                <summary>
                    Chapter 7 - Project: A Robot
                </summary>

                <blockquote>
                    Go, RoboJackets!
                </blockquote>

                <p>
                    It's a program that aggregates what's been covered so far 
                    and makes a little crawler that navigates around a 
                    <a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type)" target="_blank">graph 
                    data structure</a>. It's pretty walkthrough-ey and is 
                    about as much of a project as any one the DHTML effects I 
                    noodled out to add motion to some pages on this site. It 
                    adds a couple of new things, though:
                </p>

                <ul>
                    <li>
                        <code>const frozenObj = Object.freeze(obj)</code> // frozenObj will ignore any changes made to its properties
                    </li>
                    <li>
                        <code>const roll = Symbol('roll'); Array.prototype[roll] = function() { return this[Math.floor(Math.random() * this.length)]; };</code> // adds arr[roll]() method to arrays that returns a random element from that array
                    </li>
                    <li>
                        // all prototype changes to commonly used objects should be done through a Symbol address, to avoid naming collisions
                    </li>
                    <li>
                        <code>let {property, item} = obj;</code> // can assign variable bindings from an object with properties of the same names
                    </li>
                </ul>

                <h2>
                    Chapter 7 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 7.1 - Measuring a Robot
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/07_robot.html#i-JrK0ADjuHH" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box. 
                            </p>

                            <pre>runRobot = function(state, robot, memory) {
for (let turn = 0;; turn++) {
        if (state.parcels.length == 0) {
            return turn;
        }
        let action = robot(state, memory);
        state = state.move(action.direction);
        memory = action.memory;
    }
};

function compareRobots(robot1, memory1, robot2, memory2) {
    let [sum1, sum2] = [0, 0];

    for(let i = 0; i < 100; i++) {
        const initialState = VillageState.random();

        sum1 += runRobot(initialState, robot1, memory1);
        sum2 += runRobot(initialState, robot2, memory2);
    }

    const [avg1, avg2] = [sum1 / 100, sum2 / 100];

    console.log(`Average 1: ${avg1}; Average 2: ${avg2}`);
    return [avg1, avg2];
};

compareRobots(routeRobot, [], goalOrientedRobot, []);
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 7.2 - Robot Efficiency
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/07_robot.html#i-VbBsQJ1lp6" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box. 
                            </p>

                            <p>
                                I think I derived some of graph theory when 
                                making this. My explanations for this are in 
                                code comments on 
                                <a href="./chapter-7-exercises.js">my 
                                JavaScript file for the chapter exercises</a>.
                            </p>

                            <pre>const buildRouteGraph = (graph) => {
    const routeGraph = {};

    // create all one-step routes
    for(const fromLocation in graph) {
        const routes = {};
        routeGraph[fromLocation] = routes;

        for(const toLocation in graph) {
            if(toLocation !== fromLocation) {
                routes[toLocation] = graph[fromLocation].includes(toLocation) ? [toLocation] : [];
            }
        }
    }

    // for each location, branch from the known routes until all destinations have routes
    for(const fromLocation in routeGraph) {
        const routesFromLocation = routeGraph[fromLocation];
        const knownLocations = [fromLocation];

        // get all known locations for this location
        for(const knownRoutes in routesFromLocation) {
            const routeToDestination = routesFromLocation[knownRoutes];
            const knownDestination = routeToDestination.length > 0 ? routeToDestination[routeToDestination.length - 1] : null;
            if(knownDestination !== null && !knownLocations.includes(knownDestination)) {
                knownLocations.push(knownDestination);
            }
        }

        // get the next step that comes after these locations, and from this, build routes to the places that weren't known
        for(const knownLocation of knownLocations) {
            const adjacentLocations = graph[knownLocation];

            for(const adjacentLocation of adjacentLocations) {
                if(!knownLocations.includes(adjacentLocation)) {
                    routesFromLocation[adjacentLocation] = routesFromLocation[knownLocation].slice();
                    routesFromLocation[adjacentLocation].push(adjacentLocation);
                    knownLocations.push(adjacentLocation);
                }
            }
        } // !!! BECAUSE KNOWN LOCATIONS EXPANDS WITH EACH SUCCESSFUL ITERATION, THIS ALSO ITERATES OVER NEW KNOWN LOCATIONS, FINDING ALL ROUTES
        // (this exceeded expected behavior upon writing; I expected it to find routes up to 2 spaces away)
    }

    return routeGraph;
};

const routeGraph = buildRouteGraph(roadGraph);
const currentState = VillageState.random();

const myRobot = (villageState, memory) => {

    // if it's not currently en-route, pick a next route
    if(memory.length === 0) {
        const currentLocation = villageState.place;

        const parcels = villageState.parcels;

        // if a parcel is held, assess its destination; if not, assess its location
        let distance = Infinity;
        for(const parcel of parcels) {
            const potentialDestination = parcel.place == currentLocation 
                ? 
                parcel.address
                :
                parcel.place
            ;
            const potentialRoute = routeGraph[currentLocation][potentialDestination];

            if(potentialRoute.length <= distance) {
                memory = potentialRoute;
                distance = memory.length;
            }
        }
    }

    return {
        direction: memory[0],
        memory: memory.slice(1)
    };
};

runRobotAnimation(currentState, myRobot, []);



// robot measurement assessment; copied from my answer to the last exercise
runRobot = function(state, robot, memory) {
    for (let turn = 0;; turn++) {
        if (state.parcels.length == 0) {
        return turn;
        }
        let action = robot(state, memory);
        state = state.move(action.direction);
        memory = action.memory;
    }
};

function compareRobots(robot1, memory1, robot2, memory2) {
    let [sum1, sum2] = [0, 0];
    
    for(let i = 0; i < 100; i++) {
        const initialState = VillageState.random();
    
        sum1 += runRobot(initialState, robot1, memory1);
        sum2 += runRobot(initialState, robot2, memory2);
    }
    
    const [avg1, avg2] = [sum1 / 100, sum2 / 100];
    
    console.log(`Average 1: ${avg1}; Average 2: ${avg2}`);
    return [avg1, avg2];
};

// myRobot average: ~12.5, goalOrientedRobot average: ~15
compareRobots(myRobot, [], goalOrientedRobot, []);
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 7.3 - Persistent Group
                            </summary>

                            <p>
                                <a href="https://eloquentjavascript.net/07_robot.html#i-s+ntyh5xrm" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box. 
                            </p>

                            <pre>const PGroup = class {
    static #empty = new this([]);
    #group;

    constructor(values) {
        this.#group = values;
    }

    static get empty() {
        return this.#empty;
    }

    add(item) {
        const newGroup = this.#group.slice();

        if(!this.has(item)) {
            newGroup.push(item);
        }

        return new PGroup(newGroup);
    }

    delete(item) {
        const newGroup = this.#group.slice();
        const itemIndex = newGroup.indexOf(item);

        if(itemIndex !== -1) {
            newGroup.splice(itemIndex, 1);
        }

        return new PGroup(newGroup);
    }

    has(item) {
        return this.#group.includes(item);
    }
};

let a = PGroup.empty.add("a");
let ab = a.add("b");
let b = ab.delete("a");

console.log(b.has("b"));
// → true
console.log(a.has("b"));
// → false
console.log(b.has("a"));
// → false
</pre>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-8">
                <summary>
                    Chapter 8 - Bugs and Errors
                </summary>

                <blockquote>
                    I start from the wall outlet, then I check the power 
                    supply unit, then I check the motherboard, ...
                </blockquote>

                <p>
                    About the only debugging feature I've used in JavaScript 
                    was exception handling & console logging, so this is 
                    mostly new territory for me. Here are some features to 
                    keep a note of from this chapter:
                </p>

                <ul>
                    <li>
                        <code>"use strict";</code> // can be used as the first line in a script or function description to enable <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank">strict mode</a>, throwing errors to help debug code

                        <ul>
                            <li>
                                <code>function fun() { "use strict"; i = 10; console.log(i) };</code>// keeps undeclared function variables from silently being declared in the global scope
                            </li>
                            <li>
                                <code>"use strict"; function fun(property) { this.property = property };</code> // keeps function variables from binding "this" to the global scope whenever the functions aren't used as methods
                            </li>
                            <li>
                                <code>"use strict"; with</code> // keeps from using "with" statements
                            </li>
                            <li>
                                <code>"ust strict"; function fun(a, b, a) {};</code> // keeps a function from getting multiple parameters with the same name
                            </li>
                            <li>
                                // + much more, but these are the features highlighted in the book
                            </li>
                        </ul>
                    </li>
                    <li>
                        <code>debugger;</code> // sets a break point in the program; in a debug-enabled environment (like the browser's F12 developer tools), this pauses the program and allows you to inspect the values of variable bindings at that point
                    </li>
                    <li>
                        <code>try { ... } finally { ... }</code> // a finally block does not stop an exception from propagating; it runs, then the exception continues up the call stack until caught
                    </li>
                    <li>
                        <code>if(thing.happens) throw new Error("thing happened");</code> // this is an "assertion" construct, asserting that something doesn't happen, by throwing an exception if it DOES happen
                    </li>
                    <li>
                        <code>const thing = new class { ... }</code> // creates an instance of an anonymous class
                    </li>
                </ul>

                <h2>
                    Chapter 8 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 8.1 - Retry
                            </summary>

                            <label for="exercise-8-1-input-1">Multiplicand 1:</label>
                            <input type="number" id="exercise-8-1-input-1" value="8" />
                            <br />
                            <br />
                            <label for="exercise-8-1-input-2">Multiplicand 2:</label>
                            <input type="number" id="exercise-8-1-input-2" value="8" />
                            <br />
                            <br />
                            Product: 
                            <code id="exercise-8-1"></code>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 8.2 - The Locked Box
                            </summary>

                            <p>
                                <a href="https://eloquentjavascript.net/08_error.html#i-iGlwnUbkRs" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the final 
                                code box. 
                            </p>

                            <pre>class LockedBoxError extends Error {}

const box = new class {
    locked = true;
    #content = [];

    unlock() { this.locked = false; }
    lock() { this.locked = true;  }
    get content() {
        if (this.locked) throw new LockedBoxError("Locked!");
        return this.#content;
    }
};

function withBoxUnlocked(body) {
    try {
        box.unlock();

        body();
    } catch(e) {
        if(e instanceof LockedBoxError) {
            console.log(e);
        }

        throw e;
    } finally {
        box.lock();
    }
}

withBoxUnlocked(() => {
    box.content.push("gold piece");
});

try {
    withBoxUnlocked(() => {
        throw new Error("Pirates on the horizon! Abort!");
    });
} catch (e) {
    console.log("Error raised: " + e);
}

console.log(box.locked);
// → true

box.unlock();
console.log(box.content);
</pre>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-9">
                <summary>
                    Chapter 9 - Regular Expressions
                </summary>

                <blockquote>
                    It's slow, it's cryptic, it can always be done another 
                    way, but it is powerful.
                </blockquote>

                <p>
                    It's a one-line solution for otherwise many-line problems. 
                    Sure, it's general-use code and has the common pitfalls 
                    when compared against purpose-built code where it's 
                    applicable, but it wraps a LOT of functionality into a 
                    relatively tiny package.
                </p>

                <p>
                    Here's a long list of concepts for regular expressions in 
                    JavaScript, enough to take me from zero to practical:

                    <ul>
                        <li>
                            <code>new Regexp("abc"); /abc/;</code> // these represent the same expression; they mean "a" followed by "b" followed by "c"
                        </li>
                        <li>
                            <code>/A\+\/\/;</code> // backslashes must still be used to represent special character codes, plus a few other ones like /, +, and ?, and are not escaped to represent the backslash character (/\/ instead of /\\/ means single backslash "\")
                        </li>
                        <li>
                            <code>/abc/.test(string);</code> // tests whether the given string contains a match of the regular expression pattern
                        </li>
                        <li>
                            <code>/abc/.test(string); string.contains('abc');</code> // regex is a slower-running solution for simple tasks like this
                        </li>
                        <li>
                            <code>/[0123456789]/; /[0-9]/;</code> // both match to all strings that contain a digit
                        </li>
                        <li>
                            <code>/[a-z]/</code> // square brackets with a hyphen in the middle represent the whole range of characters between those characters, inclusive; for this, character values are their unicode values
                        </li>
                        <li>
                            <code>/[0a-z]/</code> // square brackets can be thought of as a "one of" block, where it's one of the characters in the brackets; this one represents one of either: 0 or a through z
                        </li>
                        <li>
                            // some special shortcuts

                            <ul>
                                <li>
                                    <code>/\d/</code> // any digit; same as /[0-9]/
                                </li>
                                <li>
                                    <code>/\w/</code> // any alphanumeric character
                                </li>
                                <li>
                                    <code>/\s/</code> // any whitespace character, incl. newlines
                                </li>
                                <li>
                                    <code>/\D/</code> // any NON-digit character
                                </li>
                                <li>
                                    <code>/\W/</code> // any NON-alphanumeric character
                                </li>
                                <li>
                                    <code>/\S/</code> // any NON-whitespace character
                                </li>
                                <li>
                                    <code>/./</code> // any character except for newline
                                </li>
                                <li>
                                    // the above were made with standard latin characters in mind; international characters may have unintended behavior for the expressions that don't evaluate against whitespace
                                </li>
                                <li>
                                    <code>/p{L}/u</code> // any letter (includes unicode international characters)
                                </li>
                                <li>
                                    <code>/p{N}/u</code> // any number (includes unicode international characters); not great if actual math is to be performed on it in JS
                                </li>
                                <li>
                                    <code>/p{P}/u</code> // any punctuation (includes unicode international characters)
                                </li>
                                <li>
                                    <code>/P{L}/u</code> // any non-letter (letter includes unicode international characters)
                                </li>
                                <li>
                                    <code>/p{Script=Hangul}/u</code> // any character from the given writing system
                                </li>
                            </ul>
                        </li>
                        <li>
                            <code>/\d\d:\d\d/</code> // can mean hh:mm time
                        </li>
                        <li>
                            <code>/[\d.]/</code> // any digit or period character; special regex operators put between brackets are instead read as standard characters
                        </li>
                        <li>
                            <code>/[^01]/</code> // caret means "not," and this specific regex tests whether the value contains any character that isn't 0 or 1
                        </li>
                        <li>
                            <code>/\d+/</code> // plus means 1 or more of the preceding character definition; this matches any length of digits but not an empty input
                        </li>
                        <li>
                            <code>/\d*/</code> // asterisk means 0 or more of the preceding character definition; this matches any length of digits or no digits at all
                        </li>
                        <li>
                            <code>/\d?/</code> // question mark means optional, so 0 or 1 instance of the preceding character is allowed; this matches a no-digit or 1-digit input; /colou?r/
                        </li>
                        <li>
                            <code>/\d{2, 4}-\d{3}/</code> // brackets mean the specified amount of characters must be present; this matches a pattern of 2 to 4 digits, then a hyphen, then 3 digits, no more & no less
                        </li>
                        <li>
                            <code>/\d{5,}/</code> // comma with no entry means open-ended range; this matches 5 or more digits (but {,5} does NOT mean 5 or fewer; must use {0,5} for the lower-than range)
                        </li>
                        <li>
                            <code>/boo+(hoo+)+/</code> // parentheses group up the inner expression for the sake of the next operator; this matches "boo+" (+ applies to o) followed by "hoo+" (+ applies to o) followed by any number of "hoo+" patterns (+ applies to all of hoo+)
                        </li>
                        <li>
                            <code>/db/i</code> // trailing i means case-insensitive; this matches "db" or "Db" or "dB" or "DB"
                        </li>
                        <li>
                            <code>new RegExp('an', 'i')</code> // this is how to add trailing flags to the regular RegExp constructor
                        </li>
                        <li>
                            <code>new RegExp('an', 'gi')</code> // this regular expressions can have multiple trailing flags just by adding their flag characters
                        </li>
                        <li>
                            <code>/\d+/.exec(string)</code> // like test, but returns null for non-matching strings and an array-like object with various properties for matching strings

                            <ul>
                                <li>
                                    <code>const obj = /\d+/.exec('abc123xyz456')</code> // obj = ['123', index: 3, input: 'abc123xyz456', groups: undefined]; obj[0] = '123'; obj[0] is always the first whole match in the string
                                </li>
                                <li>
                                    <code>const obj = /\d+/.exec('abcxyz')</code> // obj = null
                                </li>
                                <li>
                                    <code>const obj = /'([^']*)'/.exec("she said 'hello'")</code> // obj[0] = "'hello'"; obj[1] = 'hello'; the second item matches the inner subexpression, in this case ([^']*)
                                </li>
                                <li>
                                    <code>/bad(ly)?/.exec('bad')</code> // obj[0] = 'bad'; obj[1] = undefined; the inner expression wasn't in the string
                                </li>
                                <li>
                                    <code>/(\d)+/.exec('123')</code> // obj[0] = '123'; obj[1] = '3'; obj[n] for subexpressions is always the last match in the string for that subexpression
                                </li>
                                <li>
                                    <code>/(?:na)+/.exec('banana')</code> // obj[0] = 'nana'; the "?:" operator means to not include the expression in the returned array-like object, so there is no obj[1] here
                                </li>
                            </ul>
                        </li>
                        <li>
                            // Date construction...

                            <ul>
                                <li>
                                    <code>new Date()</code> // gives current date & time with timezone; example: Fri Feb 02 2024 18:03:06 GMT+0100 (CET)
                                </li>
                                <li>
                                    <code>new Date(2009, 11, 9)</code> // Wed Dec 09 2009 00:00:00 GMT+0100 (CET) -- !! MONTHS ARE INDEXED FROM 0, BUT DAYS ARE INDEXED FROM 1
                                </li>
                                <li>
                                    <code>new Date(2009, 11, 9, 12, 59, 59, 999)</code> // Wed Dec 09 2009 12:59:59 GMT+0100 (CET) -- AM/PM not included
                                </li>
                                <li>
                                    <code>new Date(2009, 11, 9).getTime()</code> // 1260334800000 -- UNIX time
                                </li>
                                <li>
                                    <code>new Date(1260334800000)</code> // Wed Dec 09 2009 00:00:00 GMT+0100 (CET) -- single-argument Date constructor always takes its argument to be UNIX time
                                </li>
                                <li>
                                    <code>const date = new Date(); date.getFullYear(); date.getMonth(); date.getDate(); date.getHours(); date.getMinutes(), date.getSeconds()</code> // all give numbers, the same ones used in a constructor to reconstruct it
                                </li>
                                <li>
                                    <code>[fullMatch, month, day, year] = /(\d{1,2})-(\d{1,2})-(\d{4})/.exec("1-30-2003"); new Date(year, month - 1, day);</code> // Thu Jan 30 2003 00:00:00 GMT+0100 (CET)
                                </li>
                            </ul>
                        </li>
                        <li>
                            <code>/(\d{1,2})-(\d{1,2})-(\d{4})/.exec("100-1-30000")</code> // ['00-1-3000', '00', '1', '3000', index: 1, input: '100-1-30000', groups: undefined] -- it matches... this wants to define a better boundary

                            <ul>
                                <li>
                                    <code>/^\d+$/</code> // pseudo-character "^" defines beginning of the string, "$" defines the end; this expression matches strings starting and ending with a digit sequence
                                </li>
                                <li>
                                    <code>/^!/</code> // matches strings that start with !
                                </li>
                                <li>
                                    <code>/x^/</code> // matches nothing; this represents an x before the beginning of the string
                                </li>
                            </ul>
                        </li>
                        <li>
                            <code>/a(?=e)/.exec("braeburn")</code> // ['a'] -- fails if 'e' is missing, but doesn't include it in the matched string
                        </li>
                        <li>
                            <code>/a(?=e)e/.exec("braeburn")</code> // ['ae'] -- still passes, but includes e because (?=e) just didn't move the string position forward when it was matching, then it encountered the last e, where it DID move the position forward
                        </li>
                        <li>
                            <code>/a(?! )/.exec("a b")</code> // null -- negative look ahead, only matches if the parameter DOESN'T match
                        </li>
                        <li>
                            <code>/a(?! )/.exec("ab")</code> // ['a'] -- did not match the space after a pattern, so it returned the matched "a" substring
                        </li>
                        <li>
                            <code>/\d+ (pig|cow|chicken)s?/.test('15 pigs')</code> true -- digits, then space, then (pig or cow or chicken), then an optional "s"
                        </li>
                        <li>
                            <code>/\d+ (pig|cow|chicken)s?/.test('15 pugs')</code> false -- pipe character "|" is an "OR" operator for expressions & sub-expressions
                        </li>
                        <li>
                            <code>/^([01]+b|[\da-f]+h|\d+)$/</code> // first part means sequence of 0s & 1s followed by "b," second part means digits OR letters a through f followed by "h," and third part means sequence of digits; binary, hex, and decimal
                        </li>
                        <li>
                            <code>/^([01]+|[\da-f]+|\d+)$/.test(1234)</code> // will match the MIDDLE expression, as the regex tests from the start of the string, trying the different rules in sequence on each character one by one 
                        </li>
                        <li>
                            <code>/([01]+)+b/.test(10010110...)</code> // due to the regex implementation, this can take a long time; <a href="https://eloquentjavascript.net/09_regexp.html#p-mPh4K2VFPK" target="_blank">read this for more details</a> 
                        </li>
                        <li>
                            <code>'papa'.replace(/p/, 'm') = 'pama'; 'papa'.replace(/p/g, 'm') = 'mama';</code> // "g" flag at the end means "global," to it applies the regex to all matches in the string
                        </li>
                        <li>
                            <code>'Liskov, Barbara\nMcCarthy, John'.replace(/(\p{L}+), (\p{L}+)/gu, "$2 $1")</code> // converts "(last name), (first name)" to "(first name) (last name)" with the "$#" strings representing the parenthetical subexpressions
                        </li>
                        <li>
                            <code>'123abc456xyz'.replace(/[a-z]+/g, "|$&|") = '123|abc|456|xyz|'</code> // the "$&" expression refers to an entire matched expression in the string
                        </li>
                        <li>
                            <code>'1 lemon, 2 cabbages, 3 eggs'.replace(/(\d+) (\p{L}+),?/gu, (match, amount, ingredient) => { return ingredient + ": " + amount + ";" }) = 'lemon: 1; cabbages: 2; eggs: 3;'</code> // injects args from the regex into the function, "match" being the whole expression; can simplify JSONification!
                        </li>
                        <li>
                            <code>'1 /* a */+/* b */ 1'.replace(/\/\/.*|\/\*[^]*?\*\//g, "");</code> // the [^]* will match all characters (characters not in the empty set) until the end before backtracking to find the next part of the match; adding "?" makes it check each character for the next rule instead of reaching the end of this rule before backtracking; works with any repetition operator (?+, *?, ??, {1, 2}?)
                        </li>
                        <li>
                            <code>/[\\[.+*?(){|^$]/g</code> // matches any character literal that's represented between the first & last brackets, like \, [, ., +, and *
                        </li>
                        <li>
                            <code>'   letters'.search(/\S/) = 3</code>; search function finds the first index in a string that matches a given regular expression
                        </li>
                        <li>
                            <code>let exp = /y/g; exp.lastIndex = 3; exp.exec('xyzzy').index == 4; exp.lastIndex == 5;</code> // regex object lastIndex property can be used to change where exec searches from in a string, and it's modified after a pattern is found using exec
                        </li>
                        <li>
                            // the above only works with /g or /y options; /y only matches if the match starts at lastIndex, and /g works if the match starts at OR AFTER the lastIndex value
                        </li>
                        <li>
                            // lastIndex starts at 0, so /g searches the whole string from index 0 by default; resets to 0 when it doesn't find a further match & and its exec returns null
                        </li>
                        <li>
                            <code>'Banana'.match(/an/g)</code> // with /g, this finds ALL substrings matching the regular expression and returns them after an array; this returns ['an', 'an']
                        </li>
                        <li>
                            <code>'Banana'.matchAll(/an/g)</code> // with /g, this finds all matching substrings AND returns an iterator containing exec results for each match; [['an', index: 1, ...], ['an', index: 3, ...]]
                        </li>
                        <li>
                            <code>'Banana'.match(/an/) == /an/.exec('Banana')</code> // these two return identical results without the /g flag on the regex, incl. subexpression matches at any added array indices
                        </li>
                        <li>
                            <code>'123|abc|456|def'.split(/\|/)</code> // can use a regular expression to define what to split a string along the lines of; /\r?\n/ is particularly useful for separating the lines from a file
                        </li>
                        <li>
                            <code>/\[.]/.test("[🌹]"); /\[.]/u.test("[🌹]")</code> // without u, this returns false, but with u, this returns true, because the character being tested is 2 code points; u flag for Unicode is needed to treat these characters properly
                        </li>
                    </ul>
                </p>

                <p>
                    And that's pretty much everything. A shorter list of just 
                    the basics is in 
                    <a href="https://eloquentjavascript.net/09_regexp.html#h-ErccPg/l98" target="_blank">the 
                    summary to this chapter</a>. The book suggests the tool 
                    <a href="https://www.debuggex.com/" target="_blank">Debuggex</a> 
                    for quick quality assurance of regular expressions, to 
                    ensure that a regex will work as intended.
                </p>

                <h2>
                    Chapter 9 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 9.1 - Regexp Golf
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/09_regexp.html#i-vDM8PzwQWU" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box. 
                            </p>

                            <pre>verify(/ca[rt]/,
    ["my car", "bad cats"],
    ["camper", "high art"]);

verify(/pr?op/,
    ["pop culture", "mad props"],
    ["plop", "prrrop"]);

verify(/ferr(et|y|ari)/,
    ["ferret", "ferry", "ferrari"],
    ["ferrum", "transfer A"]);

verify(/\wious(\s|$)/,
    ["how delicious", "spacious room"],
    ["ruinous", "consciousness"]);

verify(/\s[.,:;]/,
    ["bad punctuation ."],
    ["escape the period"]);

verify(/\w{6,}/,
    ["Siebentausenddreihundertzweiundzwanzig"],
    ["no", "three small words"]);

verify(/(^|\s)[^\P{L}eE]+(\s|$)/u,
    ["red platypus", "wobbling nest"],
    ["earth bed", "bedrøvet abe", "BEET"]);


function verify(regexp, yes, no) {
    // Ignore unfinished exercises
    if (regexp.source == "...") return;
    for (let str of yes) if (!regexp.test(str)) {
        console.log(`Failure to match '${str}'`);
    }
    for (let str of no) if (regexp.test(str)) {
        console.log(`Unexpected match for '${str}'`);
    }
}
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 9.2 - Quoting Style
                            </summary>

                            <label for="exercise-9-2-1">When the below text box contains apostrophes that aren't being used to form contractions, the button will convert those apostrophes into quotation marks.</label>
                            <br />
                            <input type="text" id="exercise-9-2-1" value="'I'm the cook,' he said, 'it's my job.'" style="width: 100%;" />
                            <br />
                            <button id="exercise-9-2-2">REPLACE QUOTATION MARKS</button>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 9.3 - Numbers Again
                            </summary>

                            <label for="exercise-9-3-input">Enter a number in decimal format (can be scientific notation):</label>
                            <br />
                            <input type="text" id="exercise-9-3-input" value="-1.3e12" />
                            <br />
                            <br />
                            IS THE ABOVE A NUMBER? <code id="exercise-9-3"></code>
                            <br />
                            <br />
                            <details>
                                <summary style="font-size: 1.2rem;">
                                    Testing values from the textbook
                                </summary>

                                <p>
                                    Should be numbers:
                                </p>

                                <ul>
                                    <li>
                                        1
                                    </li>
                                    <li>
                                        -1
                                    </li>
                                    <li>
                                        +15
                                    </li>
                                    <li>
                                        1.55
                                    </li>
                                    <li>
                                        .5
                                    </li>
                                    <li>
                                        5.
                                    </li>
                                    <li>
                                        1.3e2
                                    </li>
                                    <li>
                                        1E-4
                                    </li>
                                    <li>
                                        1e+12
                                    </li>
                                </ul>

                                <p>
                                    Should not be numbers:
                                </p>

                                <ul>
                                    <li>
                                        1a
                                    </li>
                                    <li>
                                        +-1
                                    </li>
                                    <li>
                                        1.2.3
                                    </li>
                                    <li>
                                        1+1
                                    </li>
                                    <li>
                                        1e4.5
                                    </li>
                                    <li>
                                        .5.
                                    </li>
                                    <li>
                                        1f5
                                    </li>
                                    <li>
                                        .
                                    </li>
                                </ul>
                            </details>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-10">
                <summary>
                    Chapter 10 - Modules
                </summary>

                <blockquote>
                    The bread & butter needed for the frontend frameworks to 
                    jam.
                </blockquote>

                <p>
                    It's just imports & exports, how they work, and how to 
                    leverage that for JavaScript software design. Here are the 
                    chapter's concepts about ECMAscript / ES modules, plus a 
                    little extra that's helpful for my learning context:
                </p>

                <ul>
                    <li>
                        // using either "export" or "import" in a script turns it into a module
                    </li>
                    <li>
                        <code>export const myBinding = ...</code> // anything marked as "export" becomes visible to other modules; can be any classes or functions or objects or primitives, anything that can be named can be exported
                    </li>
                    <li>
                        // exports can only be made from the global context of the script; nothing can be exported directly from within a function or class or other block
                    </li>
                    <li>
                        // the set of exports in a module are collectively called the "interface" of that module
                    </li>
                    <li>
                        <code>import {myBinding, myOtherBinding} from "./my-bindings.js";</code> // "import" can be used within scripts to access any of the specified bindings from an exporting module; those bindings must be marked as "export" in the module being exported from
                    </li>
                    <li>
                        // the above means that anything not marked as "export" is not visible to any outside module
                    </li>
                    <li>
                        // the set of imports in a module are collectively called the "dependencies" of that module
                    </li>
                    <li>
                        <code>import {myBinding as myVar} from "./my-bindings.js";</code> // can rename an imported binding upon its import; this importing module will use "myVar" in place of "myBinding" to refer to that binding
                    </li>
                    <li>
                        // the above is especially important for managing the namespace, as it allows the use of bindings that might otherwise be incompatible because they share a name
                    </li>
                    <li>
                        <code>export default ['a', 1, true]</code> // export default can only be defined once in a module, it can be nameless within the module, and it's usually used in modules that only have a single export
                    </li>
                    <li>
                        <code>import myArray from "./my-bindings.js"</code> // default exports can be imported without brackets and named by the importing module
                    </li>
                    <li>
                        <code>import * as bindingsObj from "./my-bindings.js"; bindings.myArray</code> // "import *" means the import name becomes an object that holds all the exports from the exporting module
                    </li>
                    <li>
                        <code>&lt;script type="module"&gt;</code> // type="module" is required to use modules with inline scripts on an HTML page
                    </li>
                    <li>
                        <code>import {parse} from "ini";</code> // module addresses can be plain names (like "ini") when managed by NPM node package manager
                    </li>
                    <li>
                        // a distributable collection of code is termed a "package," and NPM is a standard distribution system for JavaScript packeges; see <a href="https://www.npmjs.com/" target="_blank">the NPM website</a> for information about creating, distributing, and utilizing packages
                    </li>
                </ul>

                <p>
                    As imports & exports were only implemented well after 
                    JavaScript was a standard in programming, a common 
                    proto-module system agreed upon by developers was 
                    CommonJS, which uses a "require" function and "exports" 
                    object to modularize JavaScript dependencies:
                </p>

                <ul>
                    <li>
                        <code>const ordinal = require("ordinal"); const {days, months} = require("date-names");</code> // "require" is implemented by a CommonJS module to return bindings that provide the module's functionality
                    </li>
                    <li>
                        <code>exports.formatDate = function(date) { return `${days[date.getDay()]}, ${months[date.getMonth()]} ${ordinal(date.getDate())}, ${date.getFullYear()}`; };</code> // all of the bindings that came from "requires" above can be used to define properties for the current script's "exports" object
                    </li>
                    <li>
                        <code>const {formatDate} = require("format-date.js"); formatDate(new Date(2017, 9, 13));</code> // yet another file can then find & use the formatDate binding, using the requires function to import it
                    </li>
                    <li>
                        // NPM provides management & interoperability between CommonJS and ES modules, but writing new CommonJS is NOT recommended; it's no longer standard and can be harder to understand, but it's better to have at least this much knowledge so as to not be blindsided when it's encountered
                    </li>
                </ul>

                <p>
                    And here are some other pointers from the chapter:
                </p>

                <ul>
                    <li>
                        <code>let fun = Function('a, b', 'return a + b;');</code> // the "Function" function allows strings to be read as code; the first argument is the list of arguments for the function being defined, and the second argument is the function body that goes between the brackets
                    </li>
                    <li>
                        <code>let answer = eval('(a, b) => { return a + b }');</code> // a more powerful binding than Function, "eval" parses ANY string passed to it as JavaScript code
                    </li>
                    <li>
                        // transpilers or compilers -- converters that parse other coding styles & dialects (like TypeScript) into browser-readable JavaScript (or even to past versions of JavaScript, for backwards compatibility)
                    </li>
                    <li>
                        // bundlers -- converters that merge all the code from a module's dependencies into a single large file, as fetching a single large file generally has MUCH better performance than fetching many smaller files from many different sources
                    </li>
                    <li>
                        // minifiers -- converters that reduce the file size of a script by removing comments & renaming bindings into (often illegible but) short names like "a" and "_"
                    </li>
                    <li>
                        // for the above 3 types of converter tools, this is post-processing done with one's code, and you still want to keep the raw code, as written, for development & maintenance purposes, while the converted version is used by the live run environment
                    </li>
                </ul>

                <h2>
                    Chapter 10 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 10.1 - A Modular Robot
                            </summary>

                            <p>
                                This is a design brainstorming exercise rather 
                                than a coding exercise.
                            </p>

                            <p>
                                The top-level functionality of this program is 
                                provided by <code>runRobot</code>, so the 
                                modular structure of the program should have 
                                <code>runRobot</code> be the top-level 
                                interface to build the program around, as a 
                                <code>default export</code> from 
                                a <code>"robot"</code> file.
                            </p>

                            <p>
                                One would also need arguments to give to the 
                                <code>runRobot</code> function, which includes 
                                a <code>VillageState</code>, a 
                                <code>robot</code> function that returns an 
                                object containing its next move (in a 
                                "<code>direction</code>" property) & an 
                                arbitrary value as its <code>memory</code>, 
                                and that same arbitrary value would be passed 
                                in to the robot function as its third 
                                argument. Because the 
                                <code>VillageState</code> doesn't have the 
                                most apparent format for a developer to create 
                                one themselves, it should be able to be 
                                generated by an in-package function. That 
                                function may take in arguments to define 
                                specifics of a village state, but for the 
                                scope of the project, it can simply return the 
                                output of <code>VillageState.random()</code>. 
                                Such a function and its requirements 
                                (including the <code>VillageState</code> class 
                                itself) can be included in a 
                                <code>"village"</code> file. That function 
                                returning the output of 
                                <code>VillageState.random()</code> would be 
                                the <code>default export</code>, I would 
                                modify <code>VillageState</code> to include 
                                its <code>roadGraph</code> among its object 
                                properties, and the <code>roadGraph</code> can 
                                be generated using <code>buildGraph</code> and 
                                injected through a slightly extended 
                                <code>VillageState</code> constructor.
                            </p>

                            <p>
                                Due to the above, <code>buildGraph</code> may 
                                be separated into a module and its output used 
                                as the default argument for the 
                                <code>"village" default export</code> 
                                function, so that it may also be 
                                custom-defined by a developer wanting their 
                                own custom village map.
                            </p>

                            <p>
                                The <code>robot</code> argument to the 
                                <code>"robot" default export</code> function 
                                doesn't make itself apparent, so it may define 
                                <code>randomRobot</code> as a default input 
                                and have that along with 
                                <code>goalOrientedRobot</code> added to 
                                another <code>"sample-robots"</code> module, 
                                including any of their dependencies.
                            </p>

                            <p>
                                Routing operations like <code>findRoute</code> 
                                may be executed with something like 
                                <code>"dijskstrajs"</code> from NPM and 
                                interacted with through a translated version 
                                of the <code>roadGraph</code> that's now in 
                                the <code>VillageState</code>. For this, 
                                <code>"village"</code> may also be a 
                                dependency to the <code>"sample-robots"</code> 
                                module.
                            </p>

                            <p>
                                Sample usage of the <code>"robot"</code> 
                                module should be documented in that module, 
                                and with the prescribed dependency structure, 
                                using it just within the scope of its project 
                                should be straightforwardly simple.
                            </p>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 10.2 - Roads Module
                            </summary>

                            <p>
                                This exercise uses modular JS files and is 
                                demonstrated through my creation of the 
                                modules 
                                <a href="./chapter-10-exercises-graph.js" target="_blank">chapter-10-exercises-graph.js</a>
                                and <a href="./chapter-10-exercises-road-graph.js" target="_blank">chapter-10-exercises-road-graph.js</a>, 
                                along with the &lt;script title="Chapter 10 
                                Exercise 2" type="module"&gt; tag near the 
                                bottom of the code on this page.
                            </p>

                            <p>
                                The content of the graph will be displayed in 
                                the browser's F12 developer console.
                            </p>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 10.3 - Circular Dependencies
                            </summary>

                            <p>
                                This is a brainstorming exercise rather than a 
                                coding exercise.
                            </p>

                            <p>
                                Circular dependencies in CommonJS can work 
                                through the base script, the one defining 
                                <code>require</code>, wrapping CommonJS 
                                modules into functions and using exception 
                                handling to determine if that function is 
                                unable to run due to an unfulfilled 
                                dependency.
                            </p>

                            <p>
                                It may ultimately resolve circular 
                                dependencies by concatenating them and 
                                defining their contents through the 
                                <code>function</code> initializer so that the 
                                code that appears earlier in the concatenation 
                                can reference code that appears later, and 
                                vice-versa.
                            </p>

                            <p>
                                To determine which dependency to concatenate, 
                                the exception message may be cross-referenced 
                                with the <code>require()</code> arguments in 
                                the module, determined through regex, then 
                                that dependency can be sought, determined if 
                                circular (again through determining its 
                                <code>require()</code> args), and if it isn't 
                                circular, resolve that dependency before 
                                resolving this one. If it IS circular, then go 
                                ahead & concatenate before resolving the 
                                concatenated dependencies together.
                            </p>

                            <p>
                                Because this allows the cache to populate all 
                                modules before a CommonJS module calls 
                                <code>require()</code>, the in-module call to 
                                <code>require()</code> will be calling a 
                                pre-loaded known dependency in either 
                                dependency direction.
                            </p>

                            <p>
                                That may not be how it DOES work, but that may 
                                be how it COULD work.
                            </p>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-11">
                <summary>
                    Chapter 11 - Asynchronous Programming
                </summary>

                <blockquote>
                    MEANWHILE,
                </blockquote>

                <p>
                    I sort of understand Promises, await, and callback 
                    functions going into this, enough that I actually use them 
                    in my coding, but going by the depth of the last chapters, 
                    I'm up for some new surprises. And I know enough to know 
                    that Promises & async await deserve their own sections in 
                    my notes...
                </p>

                <p>
                    Callback functions:
                </p>

                <ul>
                    <li>
                        <code>setTimeout(() => { ... }, 1000)</code> // runs the inner function after 1 second
                    </li>
                    <li>
                        <code>myCallbackRunner(() => { ... }, "conditions")</code> // custom-made callback function; takes the function to run after the callback is fulfilled, along with the data needed to define whatever conditions will trigger the function
                    </li>
                    <li>
                        // a function that calls an asynchronous function becomes asynchronous itself...
                    </li>
                </ul>

                <p>
                    Promises:
                </p>

                <ul>
                    <li>
                        // a Promise is a receipt for a potentially future value; a Promise is called "resolved" when its value becomes available
                    </li>
                    <li>
                        <code>promise.then(something => { ... }); promise.then(sameThing => { ... });</code> // the same promise can resolve into multiple then functions, and it will send them all the value that it resolved to
                    </li>
                    <li>
                        <code>Promise.resolve(15).then( value => console.log(value + 1) )</code> // Promise.resolve will wrap the given value in a Promise that resolves to the given value; this Promise outputs 16 to the console
                    </li>
                    <li>
                        <code>Promise.resolve(() => { stuff that takes a long time })</code> // may use this to use the value of a Promise after its argument completes
                    </li>
                    <li>
                        <code>new Promise(resolve => { myCallbackRunner(arg => resolve(arg), "conditions") })</code> // Promise constructor takes a function that takes a function that returns the result value from a callback function

                        <ul>
                            <li>
                                <code>let resolver = callback => setTimeout(arg => callback(arg), 30000);</code> // 30-second timer
                            </li>
                            <li>
                                <code>let prom = new Promise(resolver);</code>
                            </li>
                            <li>
                                <code>let callback = arg => { if(arg === undefined) console.log("setTimeout doesn't send args to its callback!"); };</code>
                            </li>
                            <li>
                                <code>prom.then(callback);</code>
                            </li>
                            <li>
                                // after the above, the Promise will resolve 30 seconds after its creation, outputting the message to the console at that point
                            </li>
                            <li>
                                <code>prom.then(callback);</code> // after this, the same Promise will supply its result immediately to any callback functions chained to it; this prints the message immediately, because the Promise has already resolved by the time it's called
                            </li>
                            <li>
                                // the Promise gave its callback functions the return value that the callback runner (in this case, setTimeout) would normally give them when they're called as standard callback functions
                            </li>
                        </ul>
                    </li>
                    <li>
                        <code>promise.then(arg => arg + 1).then(argPlusOne => { ... })</code> // promise chaining; the initial promise injects its callback runner's argument into the first then function as the argument to the then function, after which it returns a Promise that can be further chained to inject the result of the previous then function
                    </li>
                    <li>
                        // the code in any "then" call executes immediately as its input becomes available
                    </li>
                    <li>
                        <code>promise.then(arg => return new Promise(callback => ...)).then(arg2 => 'arg2 is not a Promise!')</code> // Promises returned by the functions given to "then" send their Promise's resolution value, not the Promise itself, to the next "then" call
                    </li>
                    <li>
                        <code>Promise.reject()</code> // returns an immediately rejected Promise
                    </li>
                    <li>
                        <code>promise.then(...).catch(reason => {...})</code> // when a Promise is rejected / throws an exception, it passes the exception / "reason" to the nearest "catch" call; "catch" returns another Promise after handling the Promise's rejection reason
                    </li>
                    <li>
                        <code>promise.then(arg => {...}, reason => {...})</code> // the "then" call can take a second argument, a reject handler, to handle the error in case a Promise had an unhandled rejection reason before it
                    </li>
                    <li>
                        <code>new Promise((callback, reject) => setTimeout((arg, err) => { if(err) reject(err); else callback(arg); }, 30000));</code> // Promise constructor also takes an error handler in the form of a second function argument to the function passed as an argument to the constructor, along with a second argument added to the callback
                    </li>
                    <li>
                        <code>new Promise(...).then(...).catch(...).then(...)</code> // if the initial Promise is rejected and its then handler doesn't include error handling, the reason passes to the catch handler, whose return value is passed to the next then handler
                    </li>
                    <li>
                        <code>new Promise((successHandler, errorHandler) => { console.log(successHandler); console.log(errorHandler); })</code> // immediately logs 2 functions that return undefined; the Promise constructor implicitly injects these functions into the argument function upon being called
                    </li>
                    <li>
                        // but how does it know to inject any error arguments into callback functions used as arguments to internal function calls... could be native code, as the function injections above are also determined by the browser
                    </li>
                    <li>
                        <code>new Promise(arg => 5); new Promise(arg => arg(5));</code> // the former will never be fulfilled, but the latter is always fulfilled; the inner function's argument MUST be used for a Promise to fulfill, and static returns should be done with Promise.resolve
                    </li>
                    <li>
                        <code>Promise.reject('abc').catch(arg => console.log(arg));</code> // Promise.reject is the counterpart to Promise.resolve; creates a rejected promise with the specified return value, so this one just console.logs "abc"
                    </li>
                    <li>
                        <code>Promise.all(arr.map(item => new Promise(resolver => ...)))</code> // Promise.all converts an arrat of promises that returns a single promise that resolves into an array of results
                    </li>
                    <li>
                        // never operate directly on an external binding in Promise.all; only the initial value of that binding will be used in every array item calculation, even when other Promise stacks change that value in their own scopes
                    </li>
                    <li>
                        <code>Promise.resolve("Promise resolved").then(console.log); console.log("End of the main script");</code> // End of the main script executes before the Promise callback executes; this is because Promise actions are added to a queue in an outer JavaScript event loop that runs events in the order they're added
                    </li>
                </ul>

                <p>
                    Async & await
                </p>

                <ul>
                    <li>
                        <code>async function readFile(filename) { try {await new Promise(...); return 'success'; } catch(reason) { throw new Error('failure'); } };</code> // ANY FUNCTION MARKED "async" RETURNS A PROMISE; it just writes like a synchronous function
                    </li>
                    <li>
                        <code>await new Promise(...)</code> // await can ONLY be used in async functions; it awaits the resolution of any Promise value and either returns the resolution value or throws the reason from a rejection, continuing with the rest of the code after it's done waiting
                    </li>
                    <li>
                        <code>class MyThing { async someMethod(arg) { ... } }</code> // a method can also be async
                    </li>
                    <li>
                        <code>let somePromise = new Promise(...); ...; let someResolution = await somePromise;</code> // can declare a Promise to create the Promise & request its resolution, then await its resolution on another line
                    </li>
                </ul>

                <p>
                    Miscellaneous
                </p>

                <ul>
                    <li>
                        <code>function* generator(arg) { ... while(...){ yield val; } }</code> // generator functions, covered above in chapter 2; this works asynchronously, as it suspends execution between yields, waiting for a read from its current yield before running to the next one
                    </li>
                    <li>
                        <code>for(let value of generator(1)) { ... }</code> // the yields from a generator function can be treated as an iterator; the generator RETURNS a custom iterator, whose next value is the next yield of the function
                    </li>
                    <li>
                        <code>MyClass.prototype[Symbol.iterator] = function*() { ... };</code> // a generator function can be attached as a method to a Symbol.iterator binding in a class, to quickly turn that class into an iterable
                    </li>
                    <li>
                        // async functions can be thought of as a type of generator that produces a Promise when called and resolves on return or rejects on throw; it suspends execution during an await, which either resolves to a value or throws an exception before resuming the async function
                    </li>
                    <li>
                        // asynchronous code runs on its own call stack, not on the main thread; keeps exceptions thrown in them from ever reaching a catch statement outside of a Promise or async function
                    </li>
                </ul>

                <p>
                    ASYNC FUNCTIONS RETURN PROMISES. That's a big thing to not 
                    forget, because an async function is a easier to interpret 
                    than the Promise constructor
                </p>

                <h2>
                    Chapter 11 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 11.1 - Quiet Times
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/11_async.html#i-ClYVKLhQj7" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box 
                                (visible on scrolling down).
                            </p>

                            <pre>async function activityTable(day) {
    let logFileList = (await textFile("camera_logs.txt")).split(/\n\r?/);
    let result = new Array();
    for(const logFileName of logFileList) {
        let activityHours = (await textFile(logFileName))
            .split(/\n\r?/)
            .map(timestamp => new Date(+timestamp))
            .filter(date => date.getDay() == day)
            .map(date => date.getHours())
        ;
        let readingsForEachHour = new Array(24).fill(0);
        for(const hourReading of activityHours) {
            readingsForEachHour[hourReading]++;
        }
        result.push(readingsForEachHour);
    }
    
    result = result.reduce(
        (totals, hourReadings) => {
        for(let i = 0; i < totals.length; i++) {
            totals[i] += hourReadings[i];
        }
    
        return totals;
        }
    );
    
    return result;
}
    
activityTable(1)
    .then(table => console.log(activityGraph(table)))
;

</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 11.2 - Real Promises
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/11_async.html#i-06NEZgn6XD" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>function activityTable(day) {
    return textFile("camera_logs.txt")
        .then(logsFileContent => logsFileContent.split(/\n\r?/))
        .then(logFileList => Promise.all(
            function*() { 
                for(const logFileName of logFileList) 
                    yield textFile(logFileName); 
            }() // immediately invoked to return promise iterator
        ))
        .then(logFilesContent => {
            const hourLists = new Array();
            for(const log of logFilesContent) {
                const hourOfEachActivation =
                log.split(/\n\r?/)
                    .map(timestamp => new Date(+timestamp))
                    .filter(date => date.getDay() == day)
                    .map(date => +date.getHours())
                ;
                let totalsForEachHour = new Array(24).fill(0);
                for(const hourReading of hourOfEachActivation) {
                    totalsForEachHour[hourReading]++;
                }
        
                hourLists.push(totalsForEachHour);
            }
        
            return hourLists.reduce(
                (totals, hourReadings) => {
                    for(let i = 0; i < totals.length; i++) {
                        totals[i] += hourReadings[i];
                    }
            
                    return totals;
                }, new Array(24).fill(0)
            );
        })
    ;
};

activityTable(6)
    .then(table => console.log(activityGraph(table)))
;
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 11.3 - Building Promise.all
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/11_async.html#i-Ug+Dv9Mmsw" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>function Promise_all(promises) {
    return new Promise((resolve, reject) => {
        if(promises.length === 0)
        resolve([]);
    
        const incomplete = Symbol('incomplete');
        const result = 
            new Array(promises.length).fill(incomplete)
        ; // if the result contains this symbol, it's incomplete
    
        for(let i = 0; i < promises.length; i++) {
            promises[i].then(
                res => { result[i] = res; if(!result.includes(incomplete)) resolve(result); },
                err => { reject(err); }
            );
        }
    });
};
    
// Test code.
Promise_all([]).then(array => {
    console.log("This should be []:", array);
});
function soon(val) {
    return new Promise(resolve => {
        setTimeout(() => resolve(val), Math.random() * 500);
    });
};
Promise_all([soon(1), soon(2), soon(3)]).then(array => {
    console.log("This should be [1, 2, 3]:", array);
});
Promise_all([soon(1), Promise.reject("X"), soon(3)])
    .then(array => {
        console.log("We should not get here");
    })
    .catch(error => {
        if (error != "X") {
            console.log("Unexpected failure:", error);
        } else {
            console.log("This should be X:", error);
        }
    })
;</pre>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-12">
                <summary>
                    Chapter 12 - Project: A Programming Language
                </summary>

                <blockquote>
                    Yo, dawg, I heard you like programming languages.
                </blockquote>

                <p>
                    I'd call this one a more proper textbook project, since it 
                    mostly just uses knowledge from earlier in the book. There 
                    are some other JavaScript Error types this uses, like 
                    <code>SyntaxError</code> and <code>TypeError</code>, but 
                    other than that, it's almost all an application of 
                    previous concepts, sprinkled in with some theory.
                </p>

                <p>
                    This chapter introduces syntax trees, parsers, 
                    interpreters, and compilation, all in terms of the work 
                    that's done in this chapter. The parser turns the raw code 
                    into a syntax tree, the evaluator executes the code 
                    defined by the syntax tree, and that all adds up to an 
                    interpreter for the "Egg" language built in this chapter. 
                    Lastly, compilation is taking it a step further and 
                    preprocessing the executable code into a further optimized 
                    version of the interpreted code, frontloading as much of 
                    that processing as possible and outputting a compiled 
                    version of the code that runs faster than the language 
                    just being interpreted. For example, code in the Egg 
                    language from this chapter might compile into JavaScript, 
                    and instead of running the Egg code directly, you would 
                    compile it into JavaScript code and then run that 
                    JavaScript code instead of the Egg interpreter.
                </p>

                <h2>
                    Chapter 12 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 12.1 - Arrays
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/12_language.html#i-uQzJv9I1Z6" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>topScope.array = (...args) => args;

topScope.length = arr => arr.length;

topScope.element = (arr, index) => arr[index];

run(`
do(define(sum, fun(array,
    do(define(i, 0),
        define(sum, 0),
        while(<(i, length(array)),
            do(define(sum, +(sum, element(array, i))),
                define(i, +(i, 1)))),
        sum))),
    print(sum(array(1, 2, 3))))
`);
// → 6

</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 12.2 - Closure
                            </summary>

                            <p>
                                This is a brainstorming exercise rather than a 
                                coding exercise.
                            </p>

                            <p>
                                The JavaScript-language function represented 
                                by the Egg-language function runs a recursive 
                                sub-evaluation that passes local-scope 
                                bindings to its arguments in place of the 
                                program's higher scope. This higher scope is 
                                the prototype of the local scope by way of any 
                                higher scopes (including that from other 
                                functions!) being passed in as the second 
                                argument to the "fun" special form definition 
                                before being used as the prototype of the 
                                function's local scope through the local scope 
                                effectively being defined by 
                                <code>Object.create(higherScope)</code>. This 
                                makes a function's scope visible to all of its 
                                embedded functions, as well as functions 
                                embedded in those sub-functions, recursively.
                            </p>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 12.3 - Comments
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/12_language.html#i-/OBuIOX390" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>function skipSpace(string) {
    let first = string.search(/\S/);
    if (first == -1) return "";
    
    let result = string.slice(first);
    if(result[0] === '#') {
        result = result.slice(/^.*?(\n\r?|$)/.exec(result)[0].length);
        if(!result.length) return "";
        result = skipSpace(result);
    }
    
    return result;
};

console.log(parse("# hello\nx"));
// → {type: "word", name: "x"}

console.log(parse("a # one\n   # two\n()"));
// → {type: "apply",
//    operator: {type: "word", name: "a"},
//    args: []}

</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 12.4 - Fixing Scope
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/12_language.html#i-Y9ZDMshYCQ" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>specialForms.set = (args, scope) => {
    if (args.length != 2 || args[0].type != "word") {
        throw new SyntaxError("Incorrect use of set");
    }
    const binding = args[0].name;
    let currentScope = scope;
    do {
        if(Object.hasOwn(currentScope, binding)) {
            break;
        } else {
            currentScope = Object.getPrototypeOf(currentScope);
        }
    
        if(currentScope === null) {
            throw new ReferenceError(`Binding "${binding}" wasn't defined before set was called on it.`);
        }
    } while(true);
    
    let value = evaluate(args[1], scope);
    
    currentScope[binding] = value;
    return value;
};

run(`
do(define(x, 4),
    define(setx, fun(val, set(x, val))),
    setx(50),
    print(x))
`);
// → 50
run(`set(quux, true)`);
// → Some kind of ReferenceError

</pre>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-13">
                <summary>
                    Chapter 13 - JavaScript and the Browser
                </summary>

                <blockquote>
                    Back in familiar territory again...
                </blockquote>

                <p>
                    This chapter is a bit of background info on the Internet & 
                    how we get from zero to JavaScript. If I was formally 
                    educated in computer science, I'd probably know all about 
                    TCP/IP and the distinction between the World Wide Web and 
                    the Internet. I knew about communication protocols from my 
                    time with industrial controllers & IoT, protocols like 
                    Modbus and DeviceNet and OPC/UA. They're just languages 
                    that machines speak, and as long as both machines speak 
                    that language, they can communicate meaningfully with each 
                    other. HTTP is a structured request-and-reply resource 
                    exchange protocol / language, and it happens over TCP, 
                    which is a listen-and-connect protocol / language that 
                    manages routing to listening ports. The World Wide Web is 
                    the set of these standards & languages, with the "Web" 
                    referring to the interconnections between many devices. A 
                    URL points to a protocol ("https://"), a server address / 
                    domain name to send a request to via that protocol 
                    ("nickhz.live/"), and a path to a specific resource within 
                    that server to request 
                    ("professional/self-development/eloquent-javascript-2024/index.html").
                </p>

                <p>
                    After that, it's HTML & embedding scripts. The character 
                    entities like <code>&amp;gt;</code> and 
                    <code>&amp;amp;</code> are mentioned, 
                    <a href="https://html.spec.whatwg.org/multipage/named-characters.html" target="_blank">of 
                    which there are many more</a>, but 
                    <a href="https://developer.mozilla.org/en-US/docs/Glossary/Character_reference" target="_blank">a 
                    small subset of character entities</a> is generally 
                    sufficient to meet the needs of an HTML document. The 
                    general HTML syntax & embedding JavaScript is demonstrated 
                    by this Web page. If this chapter had any exercises, this 
                    page would be sufficient to fulfill them. Press F12!
                </p>

                <h2>
                    Chapter 13 Exercises - There are none!
                </h2>
            </details>

            <hr />

            <details id="chapter-14">
                <summary>
                    Chapter 14 - The Document Object Model
                </summary>

                <blockquote>
                    Yo, dawg, I heard you like docum--
                </blockquote>

                <p>
                    It's still familiar territory for me, but this chapter 
                    also draws out alternative ways to do some things.
                </p>

                <ul>
                    <li>
                        <code>this === window</code> // the window is the top-level element that browser JavaScript runs in
                    </li>
                    <li>
                        <code>document === window.document</code> // the document is the .html document; it represents the document file, NOT the &lt;html&gt; tag
                    </li>
                    <li>
                        <code>document.documentElement</code> // this is the representation of the &lt;html&gt; tag
                    </li>
                    <li>
                        <code>document.body; document.head;</code> // these represent the &lt;body&gt; and &lt;head&gt; tags, respectively
                    </li>
                    <li>
                        <code>document.nodeType === Node.DOCUMENT_NODE; document.body.nodeType === Node.ELEMENT_NODE;</code> // the document and all of its sub-elements (incl. items like the &lt;!DOCTYPE html&gt; and the text strings between HTML tags) are types of nodes; all possible node type values can be seen by using Object.keys(Node)
                    </li>
                    <li>
                        <code>document.getElementsBy...; element.getElementsBy...</code> // element querying methods are applied to all nodes, not just the document or the body; using it as a node method restricts the search to within that node
                    </li>
                    <li>
                        <code>textNode.textContent === textNode.nodeValue</code> // for a text node, these are the same value
                    </li>
                    <li>
                        <code>Array.from(getElementsByTagName('p')); Array.from({0: 'one'; 1: 'two', length: 2});</code> // can construct an array from an object with indexed values and a length property; this means it can convert a live NodeList to a plain array that doesn't live change when the DOM is modified
                    </li>
                    <li>
                        <code>element.remove()</code> // entirely removes the element and all of its children from the DOM
                    </li>
                    <li>
                        <code>element.dataset['attribute'] === element.getAttribute('data-attribute')</code> // 2 ways to get custom "data" attributes from an element; the latter also allows selection of custom attributes that are not marked as "data-"
                    </li>
                    <li>
                        <code>element.getAttribute('class'); element.setAttribute('class', someClassName);</code> // with getAttribute, the className property uses its HTML name, "class"
                    </li>
                    <li>
                        <code>element.offsetHeight >= element.clientHeight</code> // "client" dimension properties exclude the element border
                    </li>
                    <li>
                        <code>element.getBoundingClientRect()</code> // returns an object holding dimensional parameters of the element WITH RESPECT TO THE CURRENT VIEWPORT
                    </li>
                    <li>
                        <code>pageYOffset; pageXOffest;</code> // these give the vertical & horizontal scroll positions of the current viewport
                    </li>
                    <li>
                        <code>element.querySelector('p > a')</code> // querySelector can be applied within a node
                    </li>
                </ul>

                <h2>
                    Chapter 14 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 14.1 - Build a Table
                            </summary>

                            <p>
                                Due to this exercise being a Web page, it's 
                                being presented in an iframe, with the code 
                                being in the "srcdoc" attribute of that 
                                iframe.
                            </p>

                            <iframe srcdoc="
                            <h1>Mountains</h1>

                            <div id=&quot;diag&quot;></div>
                            
                            <div id=&quot;mountains&quot;></div>
                            
                            <script>
                              const MOUNTAINS = [
                                {name: &quot;Kilimanjaro&quot;, height: 5895, place: &quot;Tanzania&quot;},
                                {name: &quot;Everest&quot;, height: 8848, place: &quot;Nepal&quot;},
                                {name: &quot;Mount Fuji&quot;, height: 3776, place: &quot;Japan&quot;},
                                {name: &quot;Vaalserberg&quot;, height: 323, place: &quot;Netherlands&quot;},
                                {name: &quot;Denali&quot;, height: 6168, place: &quot;United States&quot;},
                                {name: &quot;Popocatepetl&quot;, height: 5465, place: &quot;Mexico&quot;},
                                {name: &quot;Mont Blanc&quot;, height: 4808, place: &quot;Italy/France&quot;}
                              ];
                            
                              const mountainsParent = document.getElementById('mountains');
                              
                              const createTableFromData = (data) => {
                                const table = document.createElement('table');
                                const headerRow = document.createElement('tr');
                                const headers = new Array();
                                
                                table.appendChild(headerRow);
                                
                                for(const datum of data) {
                                  const dataRow = document.createElement('tr');
                                  table.appendChild(dataRow);
                                  
                                  const rowContent = Array.from(
                                    {length: headers.length}, 
                                    item => document.createElement('td')
                                  );
                            
                                  for(const dataCell of rowContent) {
                                    dataRow.appendChild(dataCell);
                                  }
                                  
                                  for(const property in datum) {
                                    
                                    if(!headers.includes(property)) {
                                      const headerCell = document.createElement('th');
                                      headerCell.innerText = property;
                                      headerRow.appendChild(headerCell);
                                      
                                      headers.push(property);
                            
                                      const rows = Array.from(table.children).slice(1);
                                      for(const row of rows) {
                                        const newCell = document.createElement('td');
                                        row.appendChild(newCell);
                                        rowContent.push(newCell);
                                      }
                                    }
                            
                                    const dataCell = rowContent[headers.indexOf(property)];
                                    dataCell.innerText = datum[property];
                                  }
                                }
                            
                                return table;
                              };
                              
                              mountainsParent.appendChild(createTableFromData(MOUNTAINS));
                            </script>
                            " style="resize: both"></iframe>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 14.2 - Elements by Tag Name
                            </summary>

                            <p>
                                Due to this exercise being a Web page, it's 
                                being presented in an iframe, with the code 
                                being in the "srcdoc" attribute of that 
                                iframe.
                            </p>

                            <iframe srcdoc="
                            <h1>Heading with a <span>span</span> element.</h1>
                            <p>A paragraph with <span>one</span>, <span>two</span>
                              spans.</p>

                            <script>
                            function byTagName(node, tagName) {
                              let result = new Array();

                              for(const childNode of node.children) {
                                if(childNode.nodeName.toLowerCase() == tagName) {
                                  result.push(childNode);
                                }

                                result = result.concat(byTagName(childNode, tagName));
                              }

                              return result;
                            };

                            const appendReading = (data) => {
                              const reading = document.createElement('div');
                              reading.innerText = data;
                        
                              document.body.appendChild(reading);
                            };

                            appendReading(byTagName(document.body, &quot;h1&quot;).length);
                            // → 1
                            appendReading(byTagName(document.body, &quot;span&quot;).length);
                            // → 3
                            let para = document.querySelector(&quot;p&quot;);
                            appendReading(byTagName(para, &quot;span&quot;).length);
                            // → 2
                            </script>
                            " style="resize: both"></iframe>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 14.3 - The Cat's Hat
                            </summary>

                            <p>
                                Due to this exercise being a Web page, it's 
                                being presented in an iframe, with the code 
                                being in the "srcdoc" attribute of that 
                                iframe.
                            </p>

                            <iframe srcdoc="
                            <style>body { min-height: 200px }</style>
                            <img src=&quot;img/cat.png&quot; id=&quot;cat&quot; style=&quot;position: absolute&quot;>
                            <img src=&quot;img/hat.png&quot; id=&quot;hat&quot; style=&quot;position: absolute&quot;>

                            <script>
                              let cat = document.querySelector(&quot;#cat&quot;);
                              let hat = document.querySelector(&quot;#hat&quot;);

                              let angle = 0;
                              let lastTime = null;
                              function animate(time) {
                                if (lastTime != null) angle += (time - lastTime) * 0.001;
                                lastTime = time;
                                cat.style.top = (Math.sin(angle) * 40 + 40) + &quot;px&quot;;
                                cat.style.left = (Math.cos(angle) * 200 + 230) + &quot;px&quot;;

                                hat.style.top = (Math.sin(angle + Math.PI) * 40 + 40) + &quot;px&quot;;
                                hat.style.left = (Math.cos(angle + Math.PI) * 200 + 230) + &quot;px&quot;;

                                requestAnimationFrame(animate);
                              }
                              requestAnimationFrame(animate);
                            </script>
                            " style="resize: both"></iframe>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-15">
                <summary>
                    Chapter 15 - Handling Events
                </summary>

                <blockquote>
                    Listening is arguably the most important part of 
                    communication.
                </blockquote>

                <p>
                    Event listeners, event handlers, event types, a bit of 
                    event bubbling (though the text doesn't use that word 
                    specifically), all stuff that I generally know but has 
                    some extra detail that I want written down. Not all of 
                    this is in the text, but reading the text did make me 
                    think of including all the things that are here:
                </p>

                <ul>
                    <li>
                        <code>event.type</code> // holds whether an Event object is a "click" or a "mousedown" or a "keyup" etc.
                    </li>
                    <li>
                        <code>event.stopPropagation()</code> // keeps an event from bubbling or capturing into the event handlers of parents or children
                    </li>
                    <li>
                        <code>aDivWithButtonsInside.addEventListener('click', () => { event.target === aButtonInsideTheDiv })</code> // registering an event handler on a parent will pass in events whose event.target identifies a child that the event propagates from
                    </li>
                    <li>
                        <code>event.preventDefault()</code> // used in an event handler, this prevents the event's default behavior, like changing the page on an &lt;a&gt; tag click or scrolling the page downward when the down arrow is pressed
                    </li>
                    <li>
                        <code>if(event.ctrlKey && event.altKey && event.key == " ") ...</code> // an event holds information about whether shiftKey, ctrlKey, altKey, or metaKey was being pressed when the event was created
                    </li>
                    <li>
                        <code>&lt;div tabindex&gt;</code> // the tabindex attribute allows an element to be focused by keyboard navigation, like links and inputs can be by default
                    </li>
                    <li>
                        <code>event.type === 'input'; activeElement.value</code> // input events are said to be best for handling changes to input & textarea fields, and referencing their content is to be done with the dynamic activeElement property of the document
                    </li>
                    <li>
                        <code>event.type === 'click'</code> // DETAIL: the click event fires after the mouseup event, on the most specific element that contained both the press and release of the mouse button
                    </li>
                    <li>
                        <code>event.type === 'dblclick'</code> // DETAIL: the dblcick event fires AFTER THE SECOND CLICKEVENT
                    </li>
                    <li>
                        <code>mouseEvent.clientX; mouseEvent.clientY;</code> // for mouse events, a "client" dimensional property is the px coordinate relative to the upper left of the viewport
                    </li>
                    <li>
                        <code>mouseEvent.pageX; mouseEvent.pageY;</code> // for mouse events, a "page" dimensional property is the px coordinate relative to the upper left of the entire document
                    </li>
                    <li>
                        <code>event.type === 'mousemove'; event.buttons</code> // mousemove events keep a binary identifier of buttons currently being pressed; LMB is +1, RMB is +2, and MMB is +4
                    </li>
                    <li>
                        <code>event.type === 'touchstart'; event.type === 'touchmove'; event.type === 'touchend'</code> // TOUCH EVENTS ALSO FIRE MOUSE EVENTS AFTERWARD; can use preventDefault() to keep the mouse event from firing
                    </li>
                    <li>
                        <code>touchEvent.touches[0]</code> // a touch event has an array-like "touches" property, the elements of which hold the clientX, clientY, pageX, and pageY properties for each touch
                    </li>
                    <li>
                        <code>event.type === 'scroll'; event.preventDefault()</code> // scroll events happen AFTER the page has already scrolled, so page scrolling is not prevented by preventDefault()
                    </li>
                    <li>
                        <code>innerHeight; innerWidth;</code> // dynamic window properties that give the dimensions of the viewport
                    </li>
                    <li>
                        <code>pageYOffset; pageXOffset;</code> // dynamic window properties that give how far the viewport has scrolled; gives coordinate from the top left of the document to the top left of the viewport
                    </li>
                    <li>
                        <code>event.type === 'focus'; event.type === 'blur';</code> // fires when an element is focused or unfocused; THIS EVENT DOES NOT BUBBLE TO OTHER ELEMENTS IN ITS NODE HIERARCHY BY DEFAULT
                    </li>
                    <li>
                        <code>event.type === 'load'</code> // fires on the window & document.body when the page elements have completely loaded, and also fires on elements (like &lt;script&gt; and &lt;img&gt;) when they finish loading external files; THIS EVENT DOES NOT BUBBLE
                    </li>
                    <li>
                        <code>event.type === 'beforeunload'</code> // fires when a page is closed or navigated away from; when its preventDefault() is called and event.returnValue is set to a string, the browser requests confirmation on whether the user want to leave the page
                    </li>
                    <li>
                        // the event loop runs async, and an event fires, its listener only fires after the event loop is done being tied up with other work
                    </li>
                    <li>
                         // web workers operate outside the page's event loop, and the script it runs should have its own message listener

                         <ul>
                            <li>
                                IN page script: <code>let worker = new Worker('script.js'); worker.addEventListener('message', event => { event.data; }); worker.postMessage(...args);</code> // the page should invoke the worker, tell it which script to run, listen for its message, and post messages to it to work off of
                            </li>
                            <li>
                                IN script.js: <code>addEventListener('message', event => { postMessage(event.data) });</code> // web worker has its own global scope and works entirely through messages; it receives a copy of the postMessaged data, not the data itself, and data can only be in a JSONable format
                            </li>
                            <li>
                                // because a web worker has its own global scope, it can't know things like the mouse position or modify window-scoped things like DOM elements
                            </li>
                         </ul>
                    </li>
                    <li>
                        // for events that fire rapidly (like mousemove and keydown), limiting how often the event-handling code fires is called debouncing the event
                    </li>
                    <li>
                        <code>clearTimeout(setTimeoutReturnValue); clearInteral(setIntervalReturnValue); cancelAnimationFrame(requestAnimationFrameReturnValue);</code> // functions that nullify timer triggers
                    </li>
                    <li>
                        <code>element.removeEventListener('click', listenerFunction)</code> // does what it says, removing the instruction of addEventListener()
                    </li>
                    <li>
                        <code>element.dispatchEvent(new Event('click'))</code> // can programmatically activate event handlers on an element by using that element's dispatchEvent() method with a <i>synthetic</i> Event as its argument; this method is fired by the browser by default, so this is 1 to 1 with a user-supplied event
                    </li>
                </ul>

                <h2>
                    Chapter 15 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 15.1 - Balloon
                            </summary>

                            <p>
                                Press the up & down arrow keys in this frame! 
                                If you pop it, click to reset it.
                            </p>

                            <iframe srcdoc="
                            <p id=&quot;balloon&quot;>🎈</p>

                            <script>
                              const element = document.getElementById('balloon');
                              const initialSize = getComputedStyle(element).fontSize;
                              const limitSize = parseFloat(initialSize) * 3;
                              element.style.fontSize = initialSize;

                              function reset(event) {
                                element.innerText = '🎈';
                                element.style.fontSize = initialSize;
                                document.removeEventListener('click', reset);
                                document.addEventListener('keydown', inflate);
                              };

                              function inflate(event) {
                                let newSize = parseFloat(element.style.fontSize);
                                if(event.key === 'ArrowUp') {
                                  newSize *= 1.1;
                                } else if(event.key === 'ArrowDown') {
                                  newSize *= 0.9;
                                } else {
                                  return;
                                }
                                event.preventDefault();
                                
                                element.style.fontSize = newSize + 'px';

                                if(newSize > limitSize) {
                                  element.innerText = '💥';
                                  document.removeEventListener('keydown', inflate);
                                  document.addEventListener('click', reset);
                                }
                              };
                            
                              document.addEventListener('keydown', inflate);
                            </script>
                            "></iframe>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 15.2 - Mouse Trail
                            </summary>

                            <p>
                                Move the mouse around inside this frame!
                            </p>

                            <iframe srcdoc="
                              <head>
                              <style>
                                  .trail { /* className for the trail elements */
                                    position: absolute;
                                    height: 6px; width: 6px;
                                    border-radius: 3px;
                                    background: teal;
                                  }
                                  body {
                                    height: 300px; cursor: none;
                                  }
                                </style>
                              </head>
                              
                              <body>
                                <script>
                                  const LIMIT = 20;
                                  const trailers = Array.from(
                                    {length: LIMIT}, 
                                    item => { 
                                      const element = document.createElement('div');
                                      element.className = 'trail';
                                      document.body.appendChild(element);
                              
                                      return element;
                                    }
                                  );
                                  let counter = 0;
                              
                                  document.body.addEventListener('mousemove', event => {
                                    const trailer = trailers[counter % LIMIT].style;
                              
                                    trailer.top = (event.pageY - 3) + 'px';
                                    trailer.left = (event.pageX - 3) + 'px';
                              
                                    counter++;
                                  });
                                </script>
                              </body>
                            "></iframe>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 15.3 - Tabs
                            </summary>

                            <p>
                                Click the buttons in the frame to switch 
                                between 3 sets of content.
                            </p>

                            <iframe srcdoc="
                            <tab-panel>
                                <div data-tabname=&quot;one&quot;>Tab one</div>
                                <div data-tabname=&quot;two&quot;>Tab two</div>
                                <div data-tabname=&quot;three&quot;>Tab three</div>
                              </tab-panel>
                              <script>
                                function asTabs(node) {
                                  const tabs = Array.from(node.children);
                                  const buttons = Array.from(
                                    {length: tabs.length}, 
                                    item => document.createElement('button')
                                  );
                              
                                  const toggle = (toggledElement, toggler) => event => {
                                    for(let i = 0; i < tabs.length; i++) {
                                      tabs[i].style.display = 'none';
                                      buttons[i].style.removeProperty('filter');
                                    }
                              
                                    if(toggler) {
                                      toggler.style.filter = 'invert(1)';
                                    }
                              
                                    toggledElement.style.removeProperty('display');
                                  };
                              
                                  for(let i = tabs.length - 1;  i >= 0; i--) {
                                    const tab = tabs[i];
                                    const tabBtn = buttons[i];
                                    
                                    tabBtn.innerText = tab.getAttribute('data-tabname');
                                    node.prepend(tabBtn);
                              
                                    tabBtn.addEventListener('click', toggle(tab, tabBtn));
                                  }
                              
                                  toggle(tabs[0], buttons[0])();
                                }
                                asTabs(document.querySelector(&quot;tab-panel&quot;));
                              </script>
                            "></iframe>

                            <p>
                                I think it's less cool than 
                                <a href="../../../wip/" target="_blank">the 
                                ones I make in pure CSS</a>, but it does have 
                                a function function in the function that 
                                returns a function to use in a higher-order 
                                function. It's Functional&trade;!
                            </p>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-16">
                <summary>
                    Chapter 16 - Project: A Platform Game
                </summary>

                <blockquote>
                    "The gravity strength, jumping speed, and other constants 
                    in the game were determined by simply trying out some 
                    numbers and seeing which ones felt right. You can try 
                    experimenting with them." And that, I did.
                </blockquote>

                <p>
                    It all feels so disconnected until it all comes together. 
                    I think it would be better presented as one big long 
                    script that can be used as a reference during the reading, 
                    or even better: emphasize that the reader should write out 
                    this program in order to understand it best. 
                </p>

                <p>
                    At least for me, seeing the program all in one place is 
                    more readable than seeing little bits of it interspersed 
                    throughout the chapter. It makes all the arguments sent to 
                    the functions less cryptic. I guess there's a meta-lesson 
                    there, about the risks of over-modularization, but 
                    learning the lesson in real time by having to reference 
                    other parts of the page for each line of code made the 
                    exercises probably more painful than they needed to be. 
                    Albeit, over time spent with custom library-like code like 
                    this, you get used to the names & abstractions & structure 
                    of it, just not if it's a library that's only relevant for 
                    one chapter in a textbook. You just don't spend enough 
                    time with it to really know it holistically before you 
                    have to work with it, and it's like working with an alien 
                    toolbox. But we soldier on.
                </p>

                <ul>
                    <li>
                        <code>element.scrollLeft; element.scrollTop;</code> // these are modifiable scroll readings WITHIN an element; if the element has content overflow and the scroll bars within the element are not at their default position, this can read and change the positions of their inner scrollbars
                    </li>
                </ul>

                <h2>
                    Chapter 16 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 16.1 - Game Over
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/16_game.html#i-tFsh86eaJC" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>&lt;link rel="stylesheet" href="css/game.css"&gt;

&lt;body&gt;
&lt;script&gt;
  async function runGame(plans, Display) {
    const initialLives = 3;
    let lives = initialLives;
    
    for (let level = 0; level &lt; plans.length;) {
      console.log('Current lives: ' + lives);
      let status = await runLevel(new Level(plans[level]),
                                    Display);
      if (status == "won") level++;
      else if (status == "lost") {
        lives--;
      }

      if(lives &lt; 0) {
        console.log('Game over!');
        level = 0;
        lives = initialLives;
      }
    }
    console.log("You've won!");
  };
  runGame(GAME_LEVELS, DOMDisplay);
&lt;/script&gt;
&lt;/body&gt;
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 16.2 - Pausing the Game
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/16_game.html#i-cNfzuXtVqI" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>
&lt;link rel="stylesheet" href="css/game.css"&gt;

&lt;body&gt;
&lt;script&gt;
  function runLevel(level, Display) {
    let display = new Display(document.body, level);
    let state = State.start(level);
    let ending = 1;
    
    return new Promise(resolve =&gt; {
      const arrowListeners = Object.create(null);
      let paused = false;
      let arrows = trackKeys(["ArrowLeft", "ArrowRight", "ArrowUp"]);

      const animCallback = time =&gt; {
        if(paused) {
          return false;
        }
        
        state = state.update(time, arrows);
        display.syncState(state);
        if (state.status == "playing") {
          return true;
        } else if (ending &gt; 0) {
          ending -= time;
          return true;
        } else {
          display.clear();
          resolve(state.status);
          window.removeEventListener('keyup', pauser);
          untrackKeys();
          return false;
        }
      };

      const pauser = event =&gt; {
        if(event.key === 'Escape') {
          paused = !paused;

          if(!paused) {
            runAnimation(animCallback);
          }
        }
      };
        
      window.addEventListener('keyup', pauser);

      function trackKeys(keys) {
        let down = Object.create(null);
        function track(event) {
          if (keys.includes(event.key)) {
            down[event.key] = event.type == "keydown";
            event.preventDefault();
          }
        };
        arrowListeners['keydown'] = track;
        arrowListeners['keyup'] = track;

        for(const eventType in arrowListeners) {
          window.addEventListener(eventType, arrowListeners[eventType]);
        }
        return down;
      };

      function untrackKeys() {
        for(const eventType in arrowListeners) {
          window.removeEventListener(eventType, arrowListeners[eventType]);
        }
      };
        
      runAnimation(animCallback);
    });
  };
  runGame(GAME_LEVELS, DOMDisplay);
&lt;/script&gt;
&lt;/body&gt;
                            </pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 16.3 - A Monster
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                Eloquent JavaScript site. My solution is below 
                                and can be pasted & run on the code section 
                                near the bottom of 
                                <a href="https://eloquentjavascript.net/16_game.html#i-tKK8cGG5os" target="_blank">this 
                                page</a>.
                            </p>

                            <pre>
&lt;link rel="stylesheet" href="css/game.css"&gt;
&lt;style&gt;.monster { background: purple }&lt;/style&gt;
                                
&lt;body&gt;
  &lt;script&gt;
    // Complete the constructor, update, and collide methods
    class Monster {
      constructor(pos, speed) {
        this.pos = pos;
         this.speed = speed;
      }
                                
      get type() { return "monster"; }
                                
      static create(pos) {
        return new Monster(pos.plus(new Vec(0, -1)), new Vec(-2, 0));
      }
                                
      update(time, state) {
        let newPos = this.pos.plus(this.speed.times(time));
        let newSpeed = this.speed;
        if (state.level.touches(newPos, this.size, "wall")) {
          newSpeed = newSpeed.times(-1);
        }
                                
        return new Monster(newPos, newSpeed);
      }
                                
      collide(state) {
        const playerVulnerableY = 
          state.player.pos.y + state.player.size.y * 0.6
        ;
                                
        if(playerVulnerableY &lt; this.pos.y) {
          let filtered = state.actors.filter(a =&gt; a != this);
          return new State(state.level, filtered, state.status);
        }
                                        
        return new State(state.level, state.actors, "lost");
      }
    }
                                
    Monster.prototype.size = new Vec(1.2, 2);
                                
    levelChars["M"] = Monster;
                                
    runLevel(new Level(`
..................................
.################################.
.#..............................#.
.#..............................#.
.#..............................#.
.#...........................o..#.
.#..@...........................#.
.##########..............########.
..........#..o..o..o..o..#........
..........#...........M..#........
..........################........
..................................
`), DOMDisplay);
  &lt;/script&gt;
&lt;/body&gt;
</pre>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-17">
                <summary>
                    Chapter 17 - Drawing on Canvas
                </summary>

                <blockquote>
                    This one might be the most exciting chapter for me! The 
                    browser yields many under-explored artforms. Up to this 
                    point, have I been drawing without a canvas?
                </blockquote>

                <p>
                    I've had my eyes on SVG & canvas. The book doesn't go much 
                    into SVG, which is understandable since JavaScript isn't a 
                    requirement for its use. Canvas is the mainstay, but 
                    there's enough covered to think that one chapter in a 
                    textbook is more of just an introduction than anything 
                    else. It's a welcome one, since one of the troubles with 
                    learning Canvas is having an idea of where to start, but 
                    now that I've peeked at the 
                    <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D" target="_blank">Canvas 
                    2d context API</a>, I realize that this chapter actually 
                    covers a significant chunk of what it can do. Its power 
                    comes from getting creative with the toolset, which I 
                    thought would've been bigger for all that it's capable of. 
                    But it really goes to show how effective this chapter is 
                    at throwing you into canvas concepts.
                </p>

                <ul>
                    <li>
                        <code>&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;</code>// SVG uses a an HTML-embeddable XML namespace separate from the rest of the document; xmlns makes the element & its children into a different namespace
                    </li>
                    <li>
                        // elements like circle & rect that are SVG-only tags can be interacted with through the DOM like regular HTML elements
                    </li>
                    <li>
                        <code>&lt;canvas width="300" height="150"&gt;&lt;/canvas&gt;</code> // canvas more directly interacts with pixels without keeping whole mathematical constructs like SVG; its default size is 300px wide by 150px tall, and it's transparent by default
                    </li>
                    <li>
                        <code>const ctx = canvasElement.getContext("2d")</code> // standard code for interacting with the canvas; it's entirely JS interfaces, with the specific interface depending on the getContext arg ("2d", "webgl", "webgpu", "webgl2", ...)
                    </li>
                    <li>
                        // the chapter is about the "2d" context, which is the one context preferred for 2d canvas rendering; the other main ones focus on 3d rendering
                    </li>
                    <li>
                        <code>ctx.fillStyle = "red"; ctx.strokeStyle = "blue"; ctx.lineWidth = 5;</code> // 2d canvas sets up with relevant properties of the context being set before a command to draw things to the screen
                    </li>
                    <li>
                        <code>ctx.fillRect(x, y, width, height); ctx.strokeRect(x, y, width, height);</code> // stroke draws an outline, fill makes the color occupy the defined inner space
                    </li>
                    <li>
                        <code>ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineTo(x3, y3); ctx.stroke(); ctx.fill();</code> // beginpath starts a new path whose elements will all be stroked or filled together, moveTo lifts the pen and places it at the specified position, lineTo moves to the specified position without lifting the pen, and the stroke & fill will color in the lines or the closed space between them
                    </li>
                    <li>
                        <code>ctx.quadraticCurveTo(controlPointx, controlPointy, nextPointX, nextPointY)</code> // paths from current point to nextPoint by first moving directly toward controlPoint & curving such that its arrival at nextPoint points directly away from controlPoint
                    </li>
                    <li>
                        <code>ctx.bezierCurveTo(ctrlPt1x, ctrlPt1y, ctrlPt2x, ctrlPt2y, nextPointX, nextPointY)</code> // like the above, but there's one control point for the current point and another control point for the next point
                    </li>
                    <li>
                        <code>ctx.closePath()</code> // takes the path along a straight line to close the figure (often to the last moveTo element)
                    </li>
                    <li>
                        <code>ctx.arc(centerX, centerY, radius, startAngleRadians, endAngleRadians)</code> // draws an arc of a circle from the specified figure; angle at 0 means the rightmost end of the circle, and angle at pi/2 means the bottom of the circle
                    </li>
                    <li>
                        // to start a new path so that filling & stroking doesn't affect other elements, call beginPath() again
                    </li>
                    <li>
                        <code>ctx.font = "italic 28px monospace"; ctx.fillText('abc', 10, 50); ctx.strokeText('123', 10, 100)</code> // can draw text; coordinates specify the bottom left of the text by default, but this can change with textAlign and textBaseline properties
                    </li>
                    <li>
                        <code>imgElement.addEventListener('load', () => ctx.drawImage(imgElement, x, y));</code> // can draw bitmaps of images onto the canvas
                    </li>
                    <li>
                        <code>ctx.clearRect(x, y, width, height)</code> // clears the canvas within the specified rectangle
                    </li>
                    <li>
                        <code>ctx.drawImage(img, xInImg, yInImg, widthInImg, heightInImg, xInCanvas, yInCanvas, widthInCanvas, heightInCanvas);</code> // 9-arg spritesheet-type image draw; specifies rectangle w/ respect to top left of the image to select a crop area, then specifies rectangle w/ respect to the top left of the canvas to select a draw location for the cropped image
                    </li>
                    <li>
                        <code>ctx.drawImage(otherCanvas, ...)</code> // can also draw from another canvas element, from an SVG, or even from a video frame
                    </li>
                    <li>
                        <code>ctx.scale(xMultiplicand, yMultiplicand); ctx.translate(xDisplacement, yDisplacement); ctx.rotate(clockwiseRadians);</code> // applies transformations to any draw definitions (like stroke or arc or even other transforms) that come after it; everything happens about the origin, which starts at the top left corner but can move with translate method calls
                    </li>
                    <li>
                        // TRANSFORMS STACK WITH ONE ANOTHER; rotate pi/2 & translate right will move the origin (and all subsequent draws) DOWNWARD, while translate right then rotate pi/2 will move the origin (& subsequent draws) RIGHTWARD
                    </li>
                    <li>
                        <code>ctx.save(); ctx.translate(20, 20); ctx.fillRect(10, 10, 10, 10); ctx.restore(); ctx.fillRect(10, 10, 10, 10);</code> // save() bookmarks the current transform state, and restore() recovers it; this code moves the origin to (20, 20), draws a rectangle at (10, 10) with respect to it ((30, 30) with respect to the default position), then recovers the origin being at (0, 0) before drawing a rectangle at (10, 10) ((10, 10) with respect to the default position)
                    </li>
                    <li>
                        <code>ctx.resetTransform()</code> // fully resets all transformations; origin is back at the top-left, x is right & y is down, and everything is at the same scale
                    </li>
                    <li>
                        <code>ctx.scale(-1, 0.1)</code> // mirrors elements about the x-axis but squishes them close along the y-axis; intuitively does the same about the y-axis & can be used to mirror about the origin with both args negative
                    </li>
                    <li>
                        // graphics interface recommendations are to use HTML/DHTML for textful elements, SVG for scalable custom-shaped elements that provide much of the functionality that comes with HTML tags, and canvas to leverage per-pixel rendering tasks (esp. postprocessing or using large numbers of elements)
                    </li>
                </ul>

                <p>
                    After this, I'm more confident in exploring the other 
                    powerful browser rendering techs instead of just 
                    defaulting to DHTML & CSS3 for artistic Web pages. And 
                    there are some visual effects I've seen that are suddenly 
                    a lot less mysterious now. Maybe I'll be making mysteries 
                    for those after me to ponder, too!
                </p>

                <h2>
                    Chapter 17 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 17.1 - Shapes
                            </summary>

                            <iframe srcdoc="
<canvas width=&quot;600&quot; height=&quot;200&quot;></canvas>
<script>
  let cx = document.querySelector(&quot;canvas&quot;).getContext(&quot;2d&quot;);
  cx.strokeStyle = 'black';

  const next = () => cx.translate(100, 0);

  const drawTrapezoid = () => {
    cx.beginPath();
    cx.moveTo(30, 80);
    cx.lineTo(70, 80);
    cx.lineTo(90, 120);
    cx.lineTo(10, 120);
    cx.closePath();
    cx.stroke();
  };

  const drawRhombus = () => {
    cx.save();
    cx.fillStyle = 'red';
    cx.translate(50, 100);
    cx.rotate(Math.PI / 4);
    cx.fillRect(-25, -25, 50, 50);
    cx.restore();
  };

  const drawZigZag = () => {
    cx.beginPath();

    let [x, y] = [10, 65];
    cx.moveTo(x, y);
    
    for(let i = 0; i < 12; i++) {
      x = 100 - x;
      y += 6;
      
      cx.lineTo(x, y);
    }

    cx.stroke();
  };

  const drawSpiral = () => {
    cx.save();
    cx.translate(50, 100);
    cx.rotate(Math.PI / 4);
    
    cx.beginPath();
    cx.moveTo(0, 0);
    let length = 1;
    let scale = 1.03;
    let rotation = 0.14;
    let delRotation = rotation / 500;
    for(let i = 0; i < 100; i++) {
      cx.lineTo(length, 0);
      cx.translate(length, 0);
      cx.rotate(rotation);

      length *= scale;
      rotation *= 1.01;
    }

    cx.stroke();
    cx.restore();
  };

  const drawStar = () => {
    cx.save();

    cx.fillStyle = 'purple';
    cx.translate(50, 100);
    cx.beginPath();
    cx.moveTo(50, 0);
    for(let i = 0; i < 8; i++) {
      cx.rotate(Math.PI / 4);
      cx.quadraticCurveTo(0, 0, 50, 0);
    }

    cx.fill();

    cx.restore();
  };

  drawTrapezoid();
  next();
  drawRhombus();
  next();
  drawZigZag();
  next();
  drawSpiral();
  next();
  drawStar();
</script>
                            " width="600" height="200"></iframe>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 17.2 - The Pie Chart
                            </summary>

                            <iframe srcdoc="
<canvas width=&quot;600&quot; height=&quot;300&quot;></canvas>
<script>
  const results = [
    {name: &quot;Satisfied&quot;, count: 1043, color: &quot;lightblue&quot;},
    {name: &quot;Neutral&quot;, count: 563, color: &quot;lightgreen&quot;},
    {name: &quot;Unsatisfied&quot;, count: 510, color: &quot;pink&quot;},
    {name: &quot;No comment&quot;, count: 175, color: &quot;silver&quot;}
  ];

  let cx = document.querySelector(&quot;canvas&quot;).getContext(&quot;2d&quot;);
  let total = results
    .reduce((sum, {count}) => sum + count, 0);
  let currentAngle = -0.5 * Math.PI;
  let centerX = 300, centerY = 150;

  // Add code to draw the slice labels in this loop.
  cx.font = 'bold 20px monospace';
  for (let result of results) {
    let sliceAngle = (result.count / total) * 2 * Math.PI;
    let textPositionAngle = currentAngle + sliceAngle / 2;
    
    cx.beginPath();
    cx.arc(centerX, centerY, 100,
           currentAngle, currentAngle + sliceAngle);
    currentAngle += sliceAngle;
    cx.lineTo(centerX, centerY);
    cx.fillStyle = result.color;
    cx.fill();

    cx.fillStyle = 'black';
    cx.textBaseline = 
      textPositionAngle <= Math.PI && textPositionAngle > 0 
      ? 
      'top'
      :
      'middle'
    ;
    cx.textAlign = 
      textPositionAngle > Math.PI / 2
      ?
      'end'
      :
      'start'
    ;
    cx.fillText(
      result.name, 
      centerX + 110 * Math.cos(textPositionAngle),
      centerY + 110 * Math.sin(textPositionAngle)
    );
  }
</script>
                            " width="600" height="300"></iframe>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 17.3 - A Bouncing Ball
                            </summary>

                            <iframe srcdoc="
<canvas width=&quot;400&quot; height=&quot;400&quot;></canvas>
<script>
  let cx = document.querySelector(&quot;canvas&quot;).getContext(&quot;2d&quot;);
  cx.fillStyle = 'purple';

  const ball = Object.create(null);
  ball.radius = 50;
  ball.speed = 200;
  ball.angle = 2 * Math.PI * Math.random();
  ball.position = {
    x: ball.radius + Math.random() * (400 - 2 * ball.radius),
    y: ball.radius + Math.random() * (400 - 2 * ball.radius)
  };
  ball.velocity = {
    x: ball.speed * Math.cos(ball.angle),
    y: ball.speed * Math.sin(ball.angle)
  };

  let lastTime = null;
  function frame(time) {
    if (lastTime != null) {
      updateAnimation(Math.min(100, time - lastTime) / 1000);
    }
    lastTime = time;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function updateAnimation(step) {
    let [xAddend, yAddend] = 
      [ball.velocity.x * step, ball.velocity.y * step]
    ;

    let [desiredX, desiredY] = 
      [
        ball.position.x + xAddend,
        ball.position.y + yAddend
      ]
    ;

    if(desiredX + ball.radius > 400) {
      ball.velocity.x = -ball.velocity.x;
      xAddend = desiredX + ball.radius - 400;
    } else if(desiredX - ball.radius < 0) {
      ball.velocity.x = -ball.velocity.x;
      xAddend = ball.radius - desiredX;
    }

    if(desiredY + ball.radius > 400) {
      ball.velocity.y = -ball.velocity.y;
      yAddend = desiredY + ball.radius - 400;
    } else if(desiredY - ball.radius < 0) {
      ball.velocity.y = -ball.velocity.y;
      yAddend = ball.radius - desiredY;
    }

    ball.position.x += xAddend;
    ball.position.y += yAddend;

    cx.clearRect(0, 0, 400, 400);

    cx.beginPath();
    cx.arc(ball.position.x, ball.position.y, ball.radius,
           0, 7)
    ;
    cx.fill();
  };
</script>
                            " width="500", height="500"></iframe>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 17.4 - Precomputed Mirroring
                            </summary>

                            <p>
                                This is a design brainstorming exercise rather 
                                than a coding exercise.
                            </p>

                            <p>
                                The title of this exercise feels like a 
                                hint...
                            </p>

                            <p>
                                To avoid having to re-compute a mirrored 
                                element for canvas, you can just overlay a DOM 
                                element. Or better yet, overlay another canvas 
                                and preload the transform by applying it to 
                                that instead.
                            </p>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-18">
                <summary>
                    Chapter 18 - HTTP and Forms
                </summary>

                <blockquote>
                    Now, let's take a look under the hood.
                </blockquote>

                <p>
                    I think that starting with the actual text of the protocol 
                    communications is a great way to start when teaching 
                    fetch. A lot of confusion can be avoided with a concrete 
                    grounding like this, demystifying what lies beneath what's 
                    being taught.
                </p>

                <ul>
                    <li>
                        // this is what an HTTP GET request looks like
                        <pre>
GET /18_http.html HTTP/1.1
Host: eloquentjavascript.net
User-Agent: Your browser's name
</pre>
                    </li>
                    <li>
                        // this is what's meant by making a GET, POST, PUT, DELETE, PATCH, (...) request; this bit of text declares the method
                    </li>
                    <li>
                        <code>GET /18_http.html HTTP/1.1</code> // HTTP request method, then the resource, then the protocol version
                    </li>
                    <li>
                        // this is what an HTTP GET response looks like
                        <pre>
HTTP/1.1 200 OK
Content-Length: 87320
Content-Type: text/html
Last-Modified: Fri, 13 Oct 2023 10:05:41 GMT

&lt;!DOCTYPE html&gt;
... the rest of the HTML document
</pre>
                    </li>
                    <li>
                        // a response body need not be an HTML document; it can be just about anything
                    </li>
                    <li>
                        <code>HTTP/1.1 200 OK</code> // protocol version, response code, human-readable response message
                    </li>
                    <li>
                        // HEADERS are the "name: value" pairs present in both requests above (like "<code>Host: eloquentjavascript.net</code>" & "<code>Content-Length: 87320</code>" bytes)
                    </li>
                    <li>
                        <code>Content-Type: text/html</code> // this header tells the browser how to handle displaying the body content
                    </li>
                    <li>
                        // some request types (incl. GET & DELETE) don't require bodies, and some response types (incl. error responses) also don't have bodies; this is technically a soft rule but is typically what Web software is built to support
                    </li>
                    <li>
                        // HTML form element constructs translate into HTTP requests

                        <pre>
&lt;form method="GET" action="example/message.html"&gt;
    &lt;input name="a" value="abc"&gt;
    &lt;input name="b" value="123"&gt;
    &lt;button type="submit"&gt;
&lt;/form&gt;
</pre>
                        ^ BECOMES:
                        
                        <pre>
GET /example/message.html?a=abc&b=123 HTTP/1.1
</pre>

                    "GET" from the form method, "/example/message.html" from the form action, "a" & "abc" from the first input, "b" & "123" from the second input, and "HTTP/1.1" version is always added by the browser
                    </li>
                    <li>
                        <code>&lt;form action="example/message.html"&gt;</code> // when no method or "GET" is specified, the inputs are packed into search params / a "query string" (like <code>?a=abc&b=123</code> above)
                    </li>
                    <li>
                        <code>encodeURIComponent("Yes?"); decodeURIComponent("Yes%3F");</code> // the "URL encoding" for characters can be dealt with using these native JavaScript encoder & decoder functions
                    </li>
                    <li>
                        // HTTP methods with bodies handle form-to-HTTP translation differently

                        <pre>
&lt;form method="POST" action="example/message.html"&gt;
    &lt;input name="a" value="abc"&gt;
    &lt;input name="b" value="123"&gt;
    &lt;button type="submit"&gt;
&lt;/form&gt;
</pre>
                                                    ^ BECOMES:
                                                    
                                                    <pre>
POST /example/message.html HTTP/1.1
Content-length: 24
Content-type: application/x-www-form-urlencoded

a=abc&b=123
</pre>
                    </li>
                    <li>
                        <code>fetch("example/data.txt").then(httpResponse => { ... })</code> // the fetch interface returns a promise that resolves into an object representing an HTTP response
                    </li>
                    <li>
                        <code>httpResponse.status === 200; httpResponse.headers.get("Content-Type") === "text/plain"</code> // the httpResponse object has various identifiers for the items in the plain-text response
                    </li>
                    <li>
                        <code>httpResponse.headers.get("cOnTeNt-TyPe") === "text/plain"</code> // httpResponse objects' header names are not case sensitive
                    </li>
                    <li>
                        <code>fetch("...").then(errorResponse => { ... }, rejection => { ... })</code> // server-side error responses will also RESOLVE a promise, and the inability to get a response will REJECT a promise
                    </li>
                    <li>
                        <code>fetch("...").then(response => response.text()).then(text => console.log(text))</code> // httpResponse.text() gets the response body as text, returned as a Promise because headers may resolve before the full text body does
                    </li>
                    <li>
                        <code>fetch("...").then(r => r.json()).then(json => console.log(json), err => console.log('not valid json'))</code> // similar to the above but for JSON; rejects the Promise if the response isn't valid JSON
                    </li>
                    <li>
                        <code>fetch("...", { method: "DELETE" }).then(httpResponse => { ... })</code> // fetch sends GET requests by default; can change this by adding a config object that sets a different "method" value
                    </li>
                    <li>
                        <code>fetch("...", { method: "POST", headers: {Range: "bytes=8-19", ...}, body: ...}).then(...)</code> // config object can also include header values & body data; body data can be in <a href="https://developer.mozilla.org/en-US/docs/Web/API/RequestInit#body" target="_blank">several different formats</a>
                    </li>
                    <li>
                        <code>... headers: {Range: "bytes=8-19", ...} ...</code> // this becomes the header "Range: bytes=8-19", which means only the 8th through 19th characters of the response body are returned; the typically valid header values are listed <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" target="_blank">right here</a>
                    </li>
                    <li>
                        // some headers will be overridden or forbidden by the environment, such as "Date" or "Origin" headers
                    </li>
                    <li>
                        <code>Access-Control-Allow-Origin: *</code> // if this header is present in a RESPONSE FROM THE SERVER, it tells the browser that it can request from any origin / domain; this is not default behavior, as <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank">CORS</a> usually disallows this
                    </li>
                    <li>
                        // REMOTE PROCEDURE CALLS are function call requests made to another machine through HTTP & responded to with the return value of that function
                    </li>
                    <li>
                        // the method used by my first backends (Java Servlets / Spring) doesn't technically use remote procedure calls, but instead uses the resources identified in the headers & bodies to configure the operation carried out by the server
                    </li>
                    <li>
                        <code>https://</code> // HTTPS is a layer over HTTP, where before data exchange, the client verifies the server by first requesting a cryptographic certificate issued by a recognized certificate authority, before using cryptography to encode every request that leaves the client or server and only be able to decode it when it gets to its destination
                    </li>
                    <li>
                        // HTML form elements are made selectable through keyboard & tabbing elements; they gain focus & blur listening
                    </li>
                    <li>
                        <code>document.activeElement</code> // the currently focused element in a document; can be useful for HTML forms
                    </li>
                    <li>
                        <code>&lt;input type="text" autofocus /&gt;</code> // the "autofocus" attribute marks a field as focused when the page is loaded; useful for a form-centric page
                    </li>
                    <li>
                        <code>&lt;input type="text" tabindex="1" /&gt;&lt;a href="./"&gt;link&lt;/a&gt;&lt;input type="text" tabindex="2" /&gt;</code> // "tabindex" allows the keyboard selection order to be manually set; tabbing after selecting the first input in this will skip the link and jump to the second input
                    </li>
                    <li>
                        <code>&lt;br tabindex="0" /&gt;</code> // can add tabindex to make any element focusable, and tabIndex="0" can be used to avoid changing the focus order from that
                    </li>
                    <li>
                        <code>&lt;input type="text" disabled /&gt;</code> // disables the element; usable on any form element
                    </li>
                    <li>
                        <code>formElement.elements === {0: inputElement, 1: otherInputElement, nameOfInputElement: inputElement, nameOfOtherInputElement: otherInputElement, ...}</code> // form elements contain an array-like map-like formElement.elements property, detailing the elements used as form controls / inputs, indexed by their "name" attributes
                    </li>
                    <li>
                        <code>&lt;button type="submit"&gt;Click&lt;/ button&gt;</code> // button type="submit" will submit a form's contents, and so will hitting the enter key while the form is focused
                    </li>
                    <li>
                        <code>formElement.addEventListener("submit", submitEvent => { ... })</code> // can use this to fire an action upon form submit; can preventDefault() on the submit event to keep the browser from navigating to the page specified in the form action, with UI instead updated through fetch & DOM manipulation while staying on the page
                    </li>
                    <li>
                        <code>textElement.selectionStart; textElement.selectionEnd;</code> // in a text element (like textarea or input type="password"), these indicate where the cursor / selection is
                    </li>
                    <li>
                        <code>document.querySelectorAll("[name=color]");</code> // selects ALL elements whose "name" attribute is as specified ("color" in this case)
                    </li>
                    <li>
                        <code>&lt;select name="my-selection" multiple&gt;&lt;option value="a"&gt;Alpha&lt;/option&gt;&lt;option value="b"&gt;Beta&lt;/option&gt;&lt;/ select&gt;</code> // select element with "multiple" allows multiple select options to be chosen
                    </li>
                    <li>
                        <code>selectElement.value = lastSelectedOption.value</code> // a select element's "value" property only holds one option's value even when "multiple" is enabled; to check all, one may get the options from the array-like <code>selectElement.options</code> and check the <code>optionElement.selected</code> attribute of every returned option
                    </li>
                    <li>
                        <code>&lt;input type="file" multiple /&gt;</code> // file inputs support a "multiple" attribute
                    </li>
                    <li>
                        <code>inputTypeFileElement.addEventListener("change", event => { input.files[0].name; input.files[0].type })</code> // an input type="file" tag can access the selected file's properties through its "change" event listener
                    </li>
                    <li>
                        <code>let reader = new FileReader(); reader.addEventListener("load", () => { reader.result; }); reader.readAsText(file);</code> // the above CANNOT DIRECTLY ACCESS FILE CONTENT; this requires an asynchronous wrapper to fetch the data, such as a FileReader with a "load" event listener and the file content being assigned to the reader.result property
                    </li>
                    <li>
                        <code>reader.addEventListener("error", () => { reader.error; });</code> // if a file reader fails its operations, it fires an "error" event, and the content of the error can be accessed through the reader.error property
                    </li>
                    <li>
                        <code>localStorage.setItem(key, value); localStorage.getItem(key) === value; localStorage.removeItem(key);</code> // basic usage of localStorage, which stores data between reloads; different domains also get different localStorage scopes
                    </li>
                    <li>
                        <code>sessionStorage.setItem(...); ...</code> // sessionStorage works similarly to localStorage but resets when the session ends (usually just when the browser closes)
                    </li>
                </ul>

                <h2>
                    Chapter 18 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 18.1 - Content Negotiation
                            </summary>

                            <p>
                                Hosting this exercise here would be 
                                hotlinking a resource from the Eloquent 
                                JavaScript site, so it is not demonstrated 
                                here. 
                                <a href="https://eloquentjavascript.net/18_http.html#i-uaWwL8WGXf" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>
const mediaTypes = [
  'text/plain', 
  'text/html', 
  'application/json', 
  'application/rainbows+unicorns'
];

for(const type of mediaTypes) {
  fetch('/author', { method: 'GET', headers:{Accept: type} })
    .then(response => response.text())
    .then(text => { 
      console.log(`For ${type}:\n\n${text}\n\n==========\n\n`);
    })
  ;
}
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 18.2 - A JavaScript Workbench
                            </summary>

                            <p>
                                Below is my solution; it can be pasted into 
                                the code area in the exercise section 
                                <a href="https://eloquentjavascript.net/18_http.html#i-wTXvIH5Wds" target="_blank">here 
                                on the textbook site</a>.
                            </p>

                            <pre>
&lt;textarea id="code"&gt;return "hi";&lt;/textarea&gt;
&lt;button id="button" onclick="executeWorkbench()"&gt;Run&lt;/button&gt;
&lt;pre id="output"&gt;&lt;/pre&gt;

&lt;script&gt;
  const code = document.getElementById('code');
  const button = document.getElementById('button');
  const output = document.getElementById('output');
                                
  const executeWorkbench = () =&gt; {
    try {
      output.style.removeProperty('color');
      output.innerText = Function('', code.value)();
    } catch(e) {
      output.style.color = 'red';
      output.innerText = e;
    }
  }
&lt;/script&gt;
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 18.3 - Conway's Game of Life
                            </summary>

                            <iframe srcdoc="
<div id=&quot;grid&quot;></div>
<button id=&quot;next&quot; onclick=&quot;iterateCells()&quot;>Next generation</button>
<p id=&quot;readout&quot;></p>

<script>
    const grid = document.getElementById('grid');
    const [w, h] = [15, 10];
    const cells = Array.from({length: h}, item => new Array(w));

    // populates checkboxes / cells
    for(let i = 0; i < cells.length; i++) {
    for(let j = 0; j < cells[i].length; j++) {
        const cell = document.createElement('input');
        cell.type = 'checkbox';
        cell.checked = Math.random() < 0.5;

        grid.appendChild(cell);
        
        cells[i][j] = cell;
    }
    grid.appendChild(document.createElement('br'));
    }

    const isAlive = (row, col) => {
    return cells[row]?.[col]?.checked;
    }

    // suffers from having been reworked a couple times
    const iterateCells = () => {
    const cellStates = Array.from({length: h}, item => new Array(w));
    
    for(let row = 0; row < cells.length; row++) {
        for(let col = 0; col < cells[row].length; col++) {
        let count = 0;

        count += isAlive(row - 1, col - 1) ? 1 : 0;
        count += isAlive(row - 1, col) ? 1 : 0;
        count += isAlive(row - 1, col + 1) ? 1 : 0;
        count += isAlive(row, col - 1) ? 1 : 0;
        count += isAlive(row, col + 1) ? 1 : 0;
        count += isAlive(row + 1, col - 1) ? 1 : 0;
        count += isAlive(row + 1, col) ? 1 : 0;
        count += isAlive(row + 1, col + 1) ? 1 : 0;

        if(count < 2 || count > 3) {
            cellStates[row][col] = false;
        } else if(count === 3) {
            cellStates[row][col] = true;
        } else {
            cellStates[row][col] = cells[row][col].checked;
        }
        }
    }

    for(let row = 0; row < cells.length; row++) {
        for(let col = 0; col < cells[row].length; col++) {
        cells[row][col].checked = cellStates[row][col];
        }
    }
    };
</script>
" width="400" height="250"></iframe>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-19">
                <summary>
                    Chapter 19 - Project: A Pixel Art Editor
                </summary>

                <blockquote>
                    Redux?
                </blockquote>

                <p>
                    This is the last of the browser JavaScript chapters. The 
                    project structure here echoes a React application with 
                    the component-based structure & state management, and I 
                    don't think that's an accident. Looking back at previous 
                    editions, then sure enough, this structure only came about 
                    when React hit the author's lips. I can appreciate the 
                    thoughtfulness of directing the skill in a way that's 
                    marketable. 
                </p>

                <p>
                    That said, I believe that knowledge of plain JavaScript, 
                    like from this book, will get a lot more mileage than 
                    knowledge of any particular UI library or framework that's 
                    built on top of JavaScript. Over the course of this book, 
                    I've learned more about all the frontend frameworks at 
                    once. It's fine enough to see how a stateful frontend 
                    application is structured without so many layers of 
                    abstraction, but I put this architecture firmly in the 
                    category of being a preference or tool rather than being 
                    the one right way to do things. It's a single methodology 
                    out of the many that can be composed with this knowledge. 
                </p>

                <ul>
                    <li>
                        <code>newState = {...oldState, ...stateUpdates}</code> // this overrides same-named properties in the old state to create a merged state
                    </li>
                    <li>
                        <code>for(const {property1, property2} of someObject) { ... }</code> // object destructure as for-of loop iteration entry
                    </li>
                    <li>
                        <code>linkElement.href = canvasElement.toDataURL(); linkElement.download = 'image.png'; link.click();</code> // can get an image URL from a canvas element, choose a file name for it, and click on a link leading to that URL to save an image from a canvas
                    </li>
                    <li>
                        <code>canvasContext.getImageData(0, 0, canvasWidth, canvasHeight).data</code> // can get image data from a canvas with this; data is a 1D array of color & alpha channels per pixel ([R1, G1, B1, A1, R2, G2, B2, A2, R3, ...] where each number denotes a pixel, value 0-255), and this may be prepared with a canvas context that has a drawImage, to get all data from a raw image
                    </li>
                    <li>
                        <code>number.toString(16)</code> // changes the radix or base of a number; easy conversion to hex
                    </li>
                </ul>

                <h2>
                    Chapter 19 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 19.1 - Keyboard Bindings
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/19_paint.html#i-BUum8+bZXE" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  // The original PixelEditor class. Extend the constructor.
  class PixelEditor {
    constructor(state, config) {
      let {tools, controls, dispatch} = config;
      this.state = state;

      const toolKeyMap = Object.create(null);
      for(const tool in tools) {
        toolKeyMap[tool[0].toLowerCase()] = tool;
      }

      this.canvas = new PictureCanvas(state.picture, pos =&gt; {
        let tool = tools[this.state.tool];
        let onMove = tool(pos, this.state, dispatch);
        if (onMove) {
          return pos =&gt; onMove(pos, this.state, dispatch);
        }
      });
      this.controls = controls.map(
        Control =&gt; new Control(state, config));
      this.dom = elt("div", { 
        tabIndex: 0,
        onkeydown: event =&gt; { 
          let selectedTool = null;
          
          if(event.key === 'z' && event.ctrlKey || event.metaKey) {
            event.preventDefault();
            dispatch({undo: true});
          } else if(event.key in toolKeyMap) {
            event.preventDefault();
            dispatch({tool: toolKeyMap[event.key]});
          }
        }
      }, this.canvas.dom, elt("br"),
                     ...this.controls.reduce(
                       (a, c) =&gt; a.concat(" ", c.dom), []));
    }
    syncState(state) {
      this.state = state;
      this.canvas.syncState(state.picture);
      for (let ctrl of this.controls) ctrl.syncState(state);
    }
  }

  document.querySelector("div")
    .appendChild(startPixelEditor({}));
&lt;/script&gt;
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 19.2 - Efficient Drawing
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/19_paint.html#i-N6J15nL9us" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  const picDiff = (oldPic, newPic) =&gt; {
    const xLimit = Math.min(oldPic.width, newPic.width);
    const yLimit = Math.min(oldPic.height, newPic.height);
    const diff = [];

    for(let x = 0; x &lt; xLimit; x++) {
      for(let y = 0; y &lt; yLimit; y++) {
        if(oldPic.pixel(x, y) !== newPic.pixel(x, y)) {
          diff.push({x, y});
        }
      }
    }

    return diff;
  };
  
  // Change this method
  PictureCanvas.prototype.syncState = function(picture) {
    if (this.picture == picture) return;

    let diff = null;
    if(this.picture) {
      diff = picDiff(this.picture, picture);
    }
    
    this.picture = picture;
    drawPicture(this.picture, diff, this.dom, scale);
  };

  function firstDraw(picture, cx, scale) {
    for (let y = 0; y &lt; picture.height; y++) {
      for (let x = 0; x &lt; picture.width; x++) {
        cx.fillStyle = picture.pixel(x, y);
        cx.fillRect(x * scale, y * scale, scale, scale);
      }
    }
  }

  // You may want to use or change this as well
  function drawPicture(picture, diff, canvas, scale) {
    let cx = canvas.getContext("2d");

    if(!diff) {
      canvas.width = picture.width * scale;
      canvas.height = picture.height * scale;
      firstDraw(picture, cx, scale);
    } else {
      for(const coord of diff) {
        cx.fillStyle = picture.pixel(coord.x, coord.y);
        cx.fillRect(coord.x * scale, coord.y * scale, scale, scale);
      }
    }
  }

  document.querySelector("div")
    .appendChild(startPixelEditor({}));
&lt;/script&gt;
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 19.3 - Circles
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/19_paint.html#i-lH0RbmdIJo" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  function circle(start, state, dispatch) {
    function drawCircle(pos) {
      let diff = {x: Math.abs(pos.x - start.x), y: Math.abs(pos.y - start.y)};
      let rSquared = diff.x * diff.x + diff.y * diff.y;
      let[maxX, maxY] = [state.picture.width, state.picture.height];

      let drawn = [];
      for(let x = 0; x &lt; maxX; x++) {
        for(let y = 0; y &lt; maxY; y++) {
          const xDiff = Math.abs(x - start.x);
          const yDiff = Math.abs(y - start.y);
          if(xDiff * xDiff + yDiff * yDiff &lt;= rSquared) {
            drawn.push({x, y, color: state.color});
          }
        }
      }
      
      dispatch({picture: state.picture.draw(drawn)});
    }
    drawCircle(start);
    return drawCircle;
  }

  let dom = startPixelEditor({
    tools: {...baseTools, circle}
  });
  document.querySelector("div").appendChild(dom);
&lt;/script&gt;
                            </pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 19.4 - Proper Lines
                            </summary>

                            <p>
                                This exercise has in-page dependencies on the 
                                textbook site. 
                                <a href="https://eloquentjavascript.net/19_paint.html#i-gbSk/YiRrs" target="_blank">Here's 
                                the link to the exercise</a>, and below is my 
                                solution that can be pasted into the code box.
                            </p>

                            <pre>
&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
  // The old draw tool. Rewrite this.
  function draw(start, state, dispatch) {
    function getSubLine(lastX, lastY, thisX, thisY, state) { // (pos)
      const [xDiff, yDiff] = 
        [thisX - lastX, thisY - lastY]
      ;
      let [xFactor, yFactor] = [
        xDiff &gt;= 0 ? 1 : -1,
        yDiff &gt;= 0 ? 1 : -1
      ];
      const abslope = Math.abs(yDiff) / Math.abs(xDiff);
      
      let drawn = [];

      if(abslope &lt;= 1) {
        let limit = Math.abs(xDiff);
        yFactor = xFactor * yDiff / xDiff;
        for(let i = 0; i &lt; limit; i++) {
          drawn.push({x: lastX + i * xFactor, y: lastY + Math.round(i * yFactor), color: state.color})
        }
      } else {
        let limit = Math.abs(yDiff);
        xFactor = yFactor * xDiff / yDiff;
        for(let i = 0; i &lt; limit; i++) {
          drawn.push({x: lastX + Math.round(i * xFactor), y: lastY + i * yFactor, color: state.color})
        }
      }
      
      return drawn;
    }
    
    function drawPixel({x, y}, state) {
      let drawn = [];
      if(state.lastDrawn && Date.now() - state.lastDrawn &lt; 200) {
        drawn = getSubLine(
          state.lastX, state.lastY, x, y, state
        );
      }
      drawn.push({x, y, color: state.color});
      
      dispatch({picture: state.picture.draw(drawn), lastX: x, lastY: y, lastDrawn: Date.now()});
    }
    drawPixel(start, state);
    return drawPixel;
  }

  function line(start, state, dispatch) {
    function drawLine(pos) {
      const [xDiff, yDiff] = 
        [pos.x - start.x, pos.y - start.y]
      ;
      let [xFactor, yFactor] = [
        xDiff &gt;= 0 ? 1 : -1,
        yDiff &gt;= 0 ? 1 : -1
      ];
      const abslope = Math.abs(yDiff) / Math.abs(xDiff);
      
      let drawn = [];

      if(abslope &lt;= 1) {
        let limit = Math.abs(xDiff);
        yFactor = xFactor * yDiff / xDiff;
        for(let i = 0; i &lt; limit; i++) {
          drawn.push({x: start.x + i * xFactor, y: start.y + Math.round(i * yFactor), color: state.color})
        }
      } else {
        let limit = Math.abs(yDiff);
        xFactor = yFactor * xDiff / yDiff;
        for(let i = 0; i &lt; limit; i++) {
          drawn.push({x: start.x + Math.round(i * xFactor), y: start.y + i * yFactor, color: state.color})
        }
      }
      
      dispatch({picture: state.picture.draw(drawn)});
    }
    drawLine(start);
    return drawLine;
  }

  let dom = startPixelEditor({
    tools: {draw, line, fill, rectangle, pick}
  });
  document.querySelector("div").appendChild(dom);
&lt;/script&gt;
</pre>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-20">
                <summary>
                    Chapter 20 - Node.js
                </summary>

                <blockquote>
                    Into the last terminal.
                </blockquote>

                <p>
                    Having the client & server both speak the same language is 
                    absolutely stellar for understanding what's going on in 
                    the client-server interaction. For all the flak you can 
                    give to server-side JavaScript, Node.js and browser 
                    JavaScript are a powerful toolset when it comes to 
                    learning & teaching about fullstack applications.
                </p>

                <ul>
                    <li>
                        <code>node hello-world.js</code> // runs the given JavaScript file and will output to the terminal; scripts run in Node have no global "this" binding by default, though some global objects like <code>process</code> are available in node
                    </li>
                    <li>
                        <code>node</code> // without an argument, the Node command opens the Node console, which works similarly to the browser developer tools console; standalone lines of JavaScript can be entered & executed here
                    </li>
                    <li>
                        <code>process.exit(0)</code> // in the Node console, this ends the console session and returns the command line to the context that called Node
                    </li>
                    <li>
                        <code>process.exit(number)</code> // any code other than 0 is an error code
                    </li>
                    <li>
                        <code>process.argv</code> // holds the command line arguments given to the running script
                    </li>
                    <li>
                        <code>node showargv.js one --and two -f "7 8"</code> // outputs an array containing all the space-separated items in the command to Node, including the path to Node.exe and the .js file path
                    </li>
                    <li>
                        <code>process.argv = ['node', '/tmp/showargv.js', 'one', '--and', 'two', '-f', '7 8']</code> // this is the argv value from a "showargv.js" script, if the script is invoked with the above command in Node
                    </li>
                    <li>
                        <code>my-script.mjs</code> // the .mjs extension is for ES modules in Node; they mark support for imports and exports and don't need the "require" function binding for modular scripting designs
                    </li>
                    <li>
                        <code>import { thing } from "node:fs"</code> // when the item being imported is not at a file path, Node looks for built-in modules or a node_modules directory; "node:fs" is a built-in filesystem module, so it imports from that
                    </li>
                    <li>
                        <code>import { robot } from "robot"</code> // this looks for a JavaScript library in "node_modules/robot" that would commonly be installed into node_modules through Node Package Manager (NPM)
                    </li>
                    <li>
                        // a Node library is just a module script that runs in Node; the below is an example

                        <ul>
                            <li>
                                <code>export default (a, b) => a + b</code> // this is the content of "folder/add.mjs"
                            </li>
                            <li>
                                <code>import adder from "./add.mjs"; console.log(adder(process.argv[2], process.argv[3]));</code> // this is the content of "folder/main.mjs"
                            </li>
                            <li>
                                <code>node main.js 3 5</code> // 35 is the console output from this whenever Node is run from the "folder/" context
                            </li>
                            <li>
                                // Node args are automatically cast to strings by default, and "add.mjs" is termed as a library
                            </li>
                        </ul>
                    </li>
                    <li>
                        // Node Package Manager (NPM) is an online JavaScript module repository, and the "npm" command comes packaged with Node.js

                        <ul>
                            <li>
                                <code>npm install ini</code> // installs the "ini" package from the NPM online repository; many packages are lightweight, and this install runs in less than a second, with it functionally just adding a 7kB "node_modules/ini/lib/ini.js" file with some documentation from its creator on how to use it
                            </li>
                            <li>
                                <code>node</code> // packages installed through NPM can be accessed from JavaScript modules, but they can also be accessed through the node console after using the node command
                            </li>
                            <li>
                                <code>const {parse} = require('ini'); parse('x = 1\ny = 2') === { x: '1', y: '2' }</code> // the "ini" module is a CommonJS module, not an ES module, and node supports both; this code require()s & uses the parse() function from the module.exports object in ini.js
                            </li>
                            <li>
                                <code>npm config ls -l | grep config</code> // this can be used to see the default locations of the "npmrc" filesystem entry that can determine where the "node_modules" folder will be; different node projects typically package their own copies of "node_modules" folder to self-contain a project with its dependencies, but a base npmrc folder is used by the console
                            </li>
                        </ul>
                    </li>
                    <li>
                        <code>npm init</code> // creates a "package.json" file that each node project should have, in the directory where npm init was called
                    </li>
                    <li>
                        <code>package name: @hernandezn/my-package</code> // putting the @ indicates that the package is within a scope, be it a user scope or an organization scope
                    </li>
                    <li>
                        <code>... "dependencies": {"dijskstrajs": "^1.0.1", "random-item": "^1.0.0"}, ...</code> // if "npm install" runs with the package.json listing dependencies like this, the install will use these dependencies as the arguments; this list auto-updates when "npm install" runs WITH user-given arguments and installs a new dependency, so dependencies stay in sync
                    </li>
                    <li>
                        <code>... "version": "1.0.0", ...</code> // package.json lists the program's own version and versions from its dependencies, using <a href="https://semver.org/" target="_blank">semantic versioning (#.#.#)</a>
                    </li>
                    <li>
                        // general semantic versioning rules for each number in the version:

                        <ul>
                            <li>
                                // MAJOR version for changes that break compatibility, to where code built on a previous version of the package would break
                            </li>
                            <li>
                                // MINOR version for when non-breaking functionality additions are made
                            </li>
                            <li>
                                // PATCH version for fixing bugs & crash cases / optimizations / other things that don't change the interface or dependencies
                            </li>
                            <li>
                                // 0.#.# versions are to be considered unstable, where anything may change at any time
                            </li>
                            <li>
                                // all versions 1.0.0 and above must have their versions incremented for ANY changes made; as a corollary, the code in any one version may never be changed
                            </li>
                            <li>
                                // when a major or minor version increments, versions below it reset to 0
                            </li>
                            <li>
                                // #.#.#-some-new.identifier.0.1-2 denotes a pre-release version with a hyphen followed by an alphanumeric identifier with hyphens and dots allowed
                            </li>
                            <li>
                                // pre-release versions indicate instability & may be backwards-incompatible, while the mainline patch version will be the backward-compatible replacement; subsequent pre-release versions for the same patch version must be in alphabetical sort order, with letters coming after numbers
                            </li>
                        </ul>
                    </li>
                    <li>
                        <code>... "some-lib": "^2.3.4", ...</code> // caret before the dependency version indicates that any compatible version may be used; in this case, that's anything at or above 2.3.4 but not EXcluding anything 3.0.0 or above
                    </li>
                    <li>
                        <code>npm publish</code> // publishes a directory that has a package.json to NPM, provided that the package name and version (both indicated in the package.json) aren't taken
                    </li>
                    <li>
                        // NPM documentation declares that all packages, <a href="https://docs.npmjs.com/creating-and-publishing-scoped-public-packages" target="_blank">scoped</a>, <a href="https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages" target="_blank">unscoped</a>, or <a href="https://docs.npmjs.com/creating-and-publishing-private-packages" target="_blank">private</a>, require an NPM user account
                    </li>
                    <li>
                        <code>import {readFile} from "node:fs"; readFile("file.txt", "utf8", (error, txt) => { if(error) throw error; console.log(txt) });</code> // from Node Filesystem module "node:fs"; readFile takes in a file name, a file character encoding, and a callback function that'll operate on the file's contents, with the callback operating AFTER the file data returns
                    </li>
                    <li>
                        <code>readFile("file.txt", (error, bytes) => { if(error) throw error; console.log(`Total bytes: ${bytes.length}\nFirst byte: ${bytes[0]}`) });</code> // with 2 arguments (no character encoding), the file content is read as an array-like object of 8-bit bytes, a "Buffer" type of object
                    </li>
                    <li>
                        <code>import {writeFile} from "node:fs"; writeFile("file.txt", "Some file content!", err => console.log(err));</code> // writeFile does what it says; all text is written with UTF-8 character encoding
                    </li>
                    <li>
                        <code>import {readdir, stat, rename, unlink} from "node:fs";</code> // several other node:fs methods, for reading directory content, viewing file metadata, renaming files, and deleting them
                    </li>
                    <li>
                        <code>import {readFile} from "node:fs/promises"; readFile("file.txt", "utf8").then(text => console.log(text))</code> // the "node:fs/promises" subpackage restructures node:fs functions to explicitly use Promises
                    </li>
                    <li>
                        <code>import {readFileSync} from "node:fs"; console.log(readFileSync("file.txt", "utf8"));</code> // node:fs functions have synchronous variants THAT CAUSE ALL PROGRAM OPERATIONS TO WAIT UNTIL THE node:fs OPERATION FINISHES
                    </li>
                    <li>
                        <code>import {createServer} from "node:http";</code> // this function is all it takes to create a simple HTTP server

                        <pre>
let server = createServer((request, response) => {
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(`&lt;h1&gt;Hello!&lt;/h1&gt;&lt;p&gt;This is ${request.url}&lt;/p&gt;`);
    response.write(`&lt;footer&gt;Method: ${request.method}&lt;/footer&gt;`);
    response.end();
});
server.listen(8000);
console.log("Listening at post 8000...");
                        </pre>

                        <ul>
                            <li>
                                // writeHead() writes the HTTP response code & content type in the HTTP response header, response.write() takes the body of the HTTP response, and response.end() commits it to send back to the client
                            </li>
                            <li>
                                // while the above is running on the local system, the HTML in the "write" argument will be served from <a href="http://localhost:8000" target="_blank">http://localhost:8000</a> or any subpage of it, like <a href="http://localhost:8000" target="_blank">http://localhost:8000/my/node-server</a>
                            </li>
                            <li>
                                // the write() function may be called multiple times to update the response with further data (which concatenates onto the last writeline by default)
                            </li>
                            <li>
                                // the function passed as an argument to createServer() is called every time a client connects to the server, so all client-to-server interaction may happen through the content of this function
                            </li>
                            <li>
                                <code>request.url</code> // erves the requested resource path, not the fully qualified url; at "http://localhost:8000", <code>request.url</code> is "/", while at "http://localhost:8000/my/node-server", <code>request.url</code> is "/my/node-server"
                            </li>
                            <li>
                                <code>request.method</code> // "GET" or "POST" or "DELETE" etc.
                            </li>
                            <li>
                                <code>console.log(request.constructor.name); console.log(response.constructor.name);</code> // the request & response types are "IncomingMessage" and "ServerResponse", respectively
                            </li>
                            <li>
                                <code>server.listen(8000)</code> // opens the 8000 port for server requests; in a simple live environment, this can just be 80, which would allow access over "http://localhost" without the port number, since 80 is the default port for HTTP requests
                            </li>
                        </ul>
                    </li>
                    <li>
                        <code>import { request } from "node:http";</code> // the function request() can be used to make HTTP requests from within Node, though fetch is still available in Node (and often simpler!)
                    </li>
                    <li>
                        // the ServerResponse response type has a "writable stream" object interface that's common in Node, which includes the "write" method (that takes a string or Buffer to add to the stream, plus a callback function to run after the method call) and an "end" method (that takes similar arguments that do the same thing)
                    </li>
                    <li>
                        <code>import { createWriteStream } from "node:fs";</code> // creates a writable stream object to a file, with the same write & end methods
                    </li>
                    <li>
                        // the IncomingMessage request type has a "readable stream" object interface, which does much of its interaction by emitting events
                    </li>
                    <li>
                        <code>request.on("data", dataChunk => response.write(dataChunk.toString())); request.on("end", () => response.end('stream ended'));</code> // readable streams' "on" method works like addEventListener; common events are "data" and "end" events that indicate when another data chunk has arrived or when the request has finished sending its data
                    </li>
                    <li>
                        <code>import { createReadStream } from "node:fs";</code> // similar to the above; this readable stream has the same "on" method that listens for "data" and "end" events
                    </li>
                    <li>
                        <code>on("data", dataChunk => ...)</code> // the dataChunk type is a binary Buffer that must be converted to the type it's meant to represent (like dataChunk.toString() does above)
                    </li>
                    <li>
                        // all of the above can be applied to create basic operation as an asynchronous server and client, where the client can request a server resource with various HTTP methods, without reloading the page

                        <ul>
                            <li>
                                // server-side code; <code>uppercase-server.mjs</code>
                                <pre>
import {createServer} from "node:http";

createServer((request, response) => {
  response.writeHead(200, {"Content-Type": "text/plain", "Access-Control-Allow-Origin": "null"});
  request.on("data", chunk =>
    response.write(chunk.toString().toUpperCase()));
  request.on("end", () => response.end());
}).listen(8000);
</pre>
                            </li>
                            <li>
                                <code>"Access-Control-Allow-Origin": "null"</code> // this allows null origins (a common default for localsystem) to request from the server resource without a CORS restriction; this is opposed to <code>"Access-Control-Allow-Origin": "*"</code> which would also work because it allows the server resource to respond to requests from ALL client origins
                            </li>
                            <li>
                                // client-side code; <code>uppercase-client.html</code>

                                <pre>
&lt;input type="text" id="text-entry" placeholder="enter some text" oninput="makeRequest()" /&gt;

&lt;p id="output"&gt;&lt;/p&gt;
&lt;script&gt;
const input = document.getElementById("text-entry");
const output = document.getElementById("output");

const makeRequest = () =&gt; fetch("http://localhost:8000/", {
  method: "POST",
  body: input.value
}).then(response =&gt; response.text()).then(text =&gt; output.innerText = text);
// → UPPERCASE VALUE OF THE INPUT                                
&lt;/script&gt;
</pre>
                            </li>
                            <li>
                                <code>node uppercase-server.mjs</code>
                                <ul>
                                    <li>
                                        // in <code>uppercase-client.html</code>, typing into the input field activates the <code>makeRequest()</code> function
                                    </li>
                                    <li>
                                        // the <code>makeRequest()</code> function fetches from <code>http://localhost:8000</code> with a POST request using a request body that's the value of the text from the input field
                                    </li>
                                    <li>
                                        // the request arrives in <code>uppercase-server.mjs</code>, which writes HTTP response code 200, a "text/plain" content type, and a "null" allowed requester origin into the header
                                    </li>
                                    <li>
                                        // in <code>uppercase-server.mjs</code>, the request is given a "data" listener that writes AND UPPERCASES each chunk from the request's body into the response as the request data arrives
                                    </li>
                                    <li>
                                        // in <code>uppercase-server.mjs</code>, the request's "end" listener closes the response writeable stream to finish sending data back to the client
                                    </li>
                                    <li>
                                        // back in <code>uppercase-client.html</code>, the response from <code>uppercase-server.mjs</code> streams into the fetch's Promise as the "response" object sent to the fetch Promise's "then" callback function
                                    </li>
                                    <li>
                                        // when the response from <code>uppercase-server.mjs</code> ends, the text from the <code>response.text()</code> Promise is completed and sent to the next "then" callback
                                    </li>
                                    <li>
                                        // the text from the response is then set as the innerText of the "output" element in <code>uppercase-client.html</code>, completing the server-client interaction
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <code>process.cwd()</code> // returns the current working directory of the node program running the command
                    </li>
                    <li>
                        <code>import {resolve, sep} from "node:path";</code> // "resolve()" resolves file paths from URLs, and "sep" provides the file-path separator used in the host operating system

                        <pre>
import {resolve, sep} from "node:path";

const basePath = process.cwd();

function urlPath(url) {
    <code>// "http://my-site/its/my%20file.txt" -&gt; "/its/my%20file.txt"</code>
    let pathName = new URL(url, 'http://d').pathname;

    <code>// "/its/my%20file.txt" -&gt; "/its/my file.txt"</code>
    let decodedPathName = decodeURIComponent(pathName);

    <code>// "/its/my file.txt" -&gt; "C:\Users\...\its\my file.txt"</code>
    let filePath = resolve(decodedPathName.slice(1));

    if(filePath != basePath && !filePath.startsWith(basePath + sep)) {
        <code>// if the file path doesn't follow the base path, throw this object (notice it doesn't have to be declared an Error type)</code>
        throw {status: 403, body: "Forbidden"};
    }

    return filePath;
};

</pre>
                    </li>
                    <li>
                        <code>(JavaScript) resolve(relativePath) == (Java) File.getCanonicalPath(relativePath)</code> // the resolve function finds the absolute location of the given path argument, resolving anything like "../" and filesystem shortcuts, after which it can be compared against the Node program's desired working directory; this ensures that the requested resource stays within the desired filesystem bounds of the program
                    </li>
                    <li>
                        <code>npm install mime-types@2.1.0</code> // this package contains a mapping between file types & MIME types

                        <pre>
import {createReadStream} from "node:fs";
import {stat, readdir} from "node:fs/promises";
import {lookup} from "mime-types";

methods.GET = async function(request) {
    <code>// the function described above</code>
    let path = urlPath(request.url);
    let stats;

    try {
        <code>// checks if file exists and whether it's a directory</code>
        stats = await stat(path);
    } catch(error) {
        <code>// error.code "ENOENT" means stat didn't find the file</code>
        if(error.code != "ENOENT") throw error;
        else return {status: 404, body: "File not found"};
    }

    if(stats.isDirectory()) {
        <code>// newline-separated files in the requested path</code>
        return {body: (await readdir(path)).join("\n")};
    } else {
        <code>// returns the file reader for the given path, along with the MIME type associated with the file extension</code>
        return {
            body: createReadStream(path),
            type: lookup(path)
        };
    }
};
</pre>
                    </li>
                    <li>
                        // the above makes the firectory contents in the node directory requestable; .txt files & directories will output plain text to the browser, .pdf files will be handled accordingly by the browser, and HTML files will be rendered to the browser
                    </li>
                    <li>
                        <code>stats.size(); stats.mtime(); stats.isDirectory()</code> // the stats return from a file has several useful diagnostic operations for the given file
                    </li>
                    <li>
                        <code>if(stats.isDirectory()) await rmdir(path); else await unlink(path); return {status: 204};</code> // using this instead of the last conditional at the end of the above function gives a file & directory deleter; HTTP status code 204 means "no content"
                    </li>
                    <li>
                        <code>import {createWriteStream} from "node:fs";</code> // can be used for a PUT method to write to files

                        <pre>
methods.PUT = async function(request) {
    let path = urlPath(request.url);
    await pipeStream(request, createWriteStream(path));
    return {status: 204};
};

function pipeStream(from, to) {
    return new Promise((resolve, reject) => {
        <code>// applies "error" listeners to the request & the file path's writestream</code>
        from.on("error", reject);
        to.on("error", reject);

        <code>// applies "finish" listener for when the write stream is to close</code>
        to.on("finish", resolve);
        
        <code>// runs the data stream from the request body to the file content</code>
        from.pipe(to);
    });
};                    
</pre>
                    </li>
                    <li>
                        // the above will write to the file path specified in the URL, with the content of that written file being the body of the request
                    </li>
                    <li>
                        // the command-line tool "curl" (in UNIX-like systems & UNIX emulators like mingw) can be used to test endpoints by calling URLs with request specifications

                        <ul>
                            <li>
                                <code>curl http://localhost:8000/file.txt</code> = <code>GET http://localhost:8000/file.txt</code> // default curl sends a GET request to the specified URL
                            </li>
                            <li>
                                <code>curl -X PUT -d "some stuff to use as the body" http://localhost:8000/file.txt</code> = <code>PUT http://localhost:8000/file.txt ... some stuff to use as the body</code> // the content after "-d" is the body (-d for data) of the request
                            </li>
                            <li>
                                <code>curl -X DELETE http://localhost:8000/file.txt</code> // sends a non-GET HTTP method without any data in the body
                            </li>
                        </ul>
                    </li>
                </ul>

                <p>
                    As this chapter doesn't aim to provide an exhaustive 
                    course on Node, here are important links provided by the 
                    text to use & learn of these tools in greater depth:
                </p>

                <ul>
                    <li>
                        <a href="https://nodejs.org/" target="_blank">Node.js</a>
                    </li>
                    <li>
                        <a href="https://www.npmjs.com/" target="_blank">Node Package Manager (NPM)</a>
                    </li>
                </ul>

                <h2>
                    Chapter 20 Exercises
                </h2>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 20.1 - Search Tool
                            </summary>

                            <p>
                                This exercise runs in a live Node.js 
                                environment.
                            </p>

                            <pre>
import {stat, readFile, readdir} from 'node:fs';
import {sep} from 'node:path';

const regex = new RegExp(process.argv[2]);
const fileNames = process.argv.slice(3);
const encoding = 'utf8';

console.log(`\nFILES WHOSE CONTENT MATCHES WITH REGEX "${regex}":\n`);

const doGrep = (files) => {
    for(const filePath of files) {
        stat(filePath, (err, stats) => {
            if(err) {
                console.log(err);
                return;
            }

            if(stats.isFile()) {
                readFile(filePath, encoding, (err, text) => {
                    if(err) {
                        console.warn(err);
                        return;
                    } else if(regex.test(text)) {
                        console.log(filePath);
                    }
                });
            } else if(stats.isDirectory()) {
                readdir(filePath, (err, folderContents) => {
                    if(err) {
                        console.warn(err);
                        return;
                    }

                    folderContents = folderContents.map((entry) => filePath + sep + entry);

                    doGrep(folderContents);
                });
            }
        });
    }
};

doGrep(fileNames);
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 20.2 - Directory Creation
                            </summary>

                            <p>
                                This exercise runs in a live Node.js 
                                environment, and to run it, it should be 
                                pasted into the 
                                <a href="https://eloquentjavascript.net/code/file_server.mjs" target="_blank">file_server.mjs 
                                file that's on the textbook site</a>. This 
                                code will allow the server script to execute 
                                the "MKDIR" HTTP method on the given URL path 
                                (i.e., the command <code>curl -X MKDIR 
                                http://localhost:8000/my-directory</code> 
                                while the script runs will allow the script to 
                                create a "my-directory" folder).
                            </p>

                            <pre>
import {mkdir} from "node:fs/promises";

methods.MKCOL = async function(request) {
    let path = urlPath(request.url);
    try {
        await stat(path);
    } catch(error) {
        if(error.code != "ENOENT") throw error;
        await mkdir(path);
    }

    return {status: 204};
};
</pre>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 20.3 - A Public Space on the Web
                            </summary>

                            <p>
                                This turned into probably a more extensive 
                                exercise than was intended by the textbook. 
                                It's a locally-running Node.js web app that 
                                provides a UI for full file-system control 
                                within a specified folder, including subfolder 
                                & file creation, file uploads, file & folder 
                                deletion, a visual structure that matches the 
                                directory structure, sandboxing against the 
                                application deleting or overwriting itself or 
                                any files that weren't sent through the 
                                application, automatically generated links to 
                                files that are added, and a UI that 
                                dynamically updates in response to changes 
                                made in the file system by the user.
                            </p>

                            <p>
                                As this mini-project is composed of a fair 
                                amount of source code, the code is not planned 
                                to be on this page. Instead, it's hosted on 
                                <a href="https://github.com/Hernandezn/nickhz.live/tree/main/nodejs/live-filesystem-webapp" target="_blank">a 
                                subfolder of this website's Github repo</a>.
                            </p>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="chapter-21">
                <summary>
                    Chapter 21 - Project: Skill-Sharing Website
                </summary>

                <blockquote>
                    The final stretch!
                </blockquote>

                <p>
                    This bit was essentially a meta-exercise in interpreting a 
                    front & backend project that's already pre-written. That's 
                    an important professional skill to have, sure, but I also 
                    appreciate it as victory lap for the reader to be able to 
                    say, "yes, I know JavaScript."
                </p>

                <p>
                    This chapter's entire project is somewhat less complicated 
                    than the one I wrote for chapter 20's final exercise, but 
                    that's at least partly because it offloads much of the 
                    complexity with its structure and its dependencies. I 
                    might have skill, but the author Marijn has skill AND 
                    experience.
                </p>

                <p>
                    They assert that creating UI elements using an element 
                    creation function that takes the tag name, tag attributes, 
                    and child elements has led to messy code, but I think it's 
                    pretty clean, so clean that it's easy to know how to make 
                    it cleaner. They've basically built the JSX that underlies 
                    React.
                </p>

                <ul>
                    <li>
                        // CommonJS modules imported through NPM can be implemented through the "import" clause instead of needing the "requires" function; this adds forward compatibility from CommonJS to ES modules
                    </li>
                    <li>
                        <code>request.headers['if-none-match']</code> // ON SERVER-SIDE; Node stores request header keys as LOWERCASE values
                    </li>
                    <li>
                        <code>await new Promise(resolve => setTimeout(resolve, 500));</code> // putting this statement in an async function is a simple way to force it to wait
                    </li>
                </ul>

                <h2>
                    Chapter 21 Exercises
                </h2>

                <p>
                    These exercises are modifications for 
                    <a href="https://eloquentjavascript.net/code/skillsharing.zip" target="_blank">the 
                    skill-sharing application code outlined in this 
                    chapter</a>.
                </p>

                <ul>
                    <li>
                        <details>
                            <summary>
                                Exercise 21.1 - Disk Persistence
                            </summary>

                            <p>
                                This solution can be defined in a few parts:
                            </p>

                            <ul>
                                <li>
                                    I created a <code>save-data.json</code> 
                                    file in the <code>skillsharing</code> 
                                    directory and gave it only an empty object 
                                    as content:

                                    <pre>{}</pre>
                                </li>
                                <li>
                                    In <code>skillsharing_server.mjs</code>, I 
                                    added this import statement to the top:

                                    <pre>import {readFile, writeFile} from 'node:fs/promises';</pre>
                                </li>
                                <li>
                                    In <code>skillsharing_server.mjs</code>, I 
                                    replaced this code:

                                    <pre>new SkillShareServer({}).start(8000);
</pre>

                                    with this code:

                                    <pre>(async () => {
  const talks = JSON.parse(await readFile('save-data.json'));

  console.log(talks);

  new SkillShareServer(talks).start(8000);
})();
</pre>
                                </li>
                                <li>
                                    In <code>skillsharing_server.mjs</code>, I 
                                    added this line to the 
                                    <code>SkillShareServer.prototype.updated</code> 
                                    function:

                                    <pre>writeFile('save-data.json', JSON.stringify(this.talks)).catch(err => { console.log('Couldn\'t write to file!'); console.log(String(err)); });</pre>
                                </li>
                            </ul>

                            <p>
                                With this, the application now reads from a 
                                save file upon starting, and it writes to that 
                                save file every time there's an update from a 
                                user. This preserving the application contents 
                                after crashes & restarts, fulfilling the 
                                feature requested by this exercise.
                            </p>
                        </details>
                    </li>
                    <li>
                        <details>
                            <summary>
                                Exercise 21.2 - Comment Field Resets
                            </summary>

                            <p>
                                All of the changes I made for this exercise 
                                are in the <code>renderTalk()</code> function 
                                defined in 
                                <code>public/skillsharing_client.js</code>:
                            </p>

                            <pre>let thisClientSubmitted = false;
function renderTalk(talk, dispatch) {
  const commentAttributes = {type: "text", name: "comment", oninput: event => { 
    localStorage.setItem('commentInProgressTalk', talk.title);
    localStorage.setItem('commentInProgressContent', event.target.value);
  }};

  if(talk.title === localStorage.getItem('commentInProgressTalk') && thisClientSubmitted === false) {
    commentAttributes.value = localStorage.getItem('commentInProgressContent');
  }
  thisClientSubmitted = false;

  const commentElement = elt("input", commentAttributes);

  const submitCommentButton = elt("button", {type: "submit", onclick: event => {
    thisClientSubmitted = true;
  }}, "Add comment");

  return elt(
    "section", {className: "talk"},
    elt("h2", null, talk.title, " ", elt("button", {
      type: "button",
      onclick() {
        dispatch({type: "deleteTalk", talk: talk.title});
      }
    }, "Delete")),
    elt("div", null, "by ",
        elt("strong", null, talk.presenter)),
    elt("p", null, talk.summary),
    ...talk.comments.map(renderComment),
    elt("form", {
      onsubmit(event) {
        event.preventDefault();
        let form = event.target;
        dispatch({type: "newComment",
                  talk: talk.title,
                  message: form.elements.comment.value});
        form.reset();
      }
    }, commentElement, " ",
       submitCommentButton));
}
</pre>

                            <p>
                                With this, the content & location of a comment 
                                in progress is saved to local storage, and if 
                                that location is encountered when the page 
                                re-renders, it restores that comment from 
                                local storage to the client's comment box. 
                                Because it uses local storage, it's also 
                                refresh-safe.
                            </p>

                            <p>
                                Additionally, because local storage is shared 
                                when two clients are on one system, the UI tracks 
                                whether a comment was submitted from that 
                                particular client, rescinding the content of the 
                                comment box only whenever the comment was 
                                submitted by this client. This lets the comment 
                                box continue to empty itself upon submit.
                            </p>
                        </details>
                    </li>
                </ul>
            </details>

            <hr />

            <details id="reflection">
                <summary>
                    Reflection
                </summary>

                <p>
                    I would recommend this book to others who want to learn 
                    JavaScript. I still believe I was fairly capable with 
                    browser JS from the beginning, but now, it feels like I've 
                    completed a toolbox that I didn't even know was 
                    incomplete! It's handed me a lot of leads for moving 
                    forward with, too. I think the intended route here is 
                    React, but I'm also interested in websockets and SVG. It's 
                    made several concepts like canvas & asynchronous code more 
                    approachable, too.
                </p>

                <p>
                    Because JavaScript is supported by the ecosystems built on 
                    it, the more complete knowledge of the pure language can 
                    feel like having all the cheat codes. I can imagine how 
                    more things must work behind the scenes now, like how JSX 
                    could be implemented similarly to how the Egg programming 
                    language from chapter 12 was, or how React & Angular 
                    components are essentially just the stateful class 
                    components created in the final chapter & handled as ES 
                    modules, with the syntactic sugar of JSX added to them. I 
                    can see through things that were once arcane, and it's 
                    thanks to the understanding from this book.
                </p>

                <p>
                    The application from the final chapter was a logical 
                    conclusion, a webapp whose UI doesn't even render without 
                    the browser running a mess of JavaScript. The mainstream 
                    Web UI frameworks have reached similar conclusions before, 
                    too, and I personally don't agree with it. There are 
                    performance reasons & bad-practice reasons & probably 
                    environmental reasons that can support me on that, but my 
                    personal core for being against it is that JavaScript 
                    should be reserved for the good stuff. It's the ace in the 
                    hole for making the impossible possible in Web UI, and 
                    when you make it handle every menial little task on the 
                    browser, what's happened is that you spread its capability 
                    thin in the developer's mind and wind up underselling what 
                    JavaScript is truly capable of. It's powerful, and there's 
                    less & less thought about that power as people abstract it 
                    away into Web frameworks that regularly try to put it in 
                    your head that you need an entire JavaScript framework for 
                    an interactive application. I don't need a single line of 
                    JavaScript for 
                    <a href="../../../wip/" target="_blank">basic functions 
                    like single-url pagination or motion graphics 
                    rendering</a> to work. The frameworks make applications 
                    that are maintainable & easy to collaborate on. They're 
                    tools that help the bottom line for larger teams, not a 
                    statement on the one right way to do things. Converging on 
                    it as if it IS the one right way to do things is probably 
                    getting at least a little caught up in the current trends, 
                    but as it's also being taught as a professional skill to 
                    help people get further along in the actual software 
                    industry, I think that part of it is commendable.
                </p>

                <p>
                    The last project did feel more like a victory lap than 
                    anything, and it makes me glad that I overcomplicated the 
                    final exercise from chapter 20, rebuilding that from 
                    scratch & adding my own new features instead of sticking 
                    strictly to the book. It gave me the chance to compose 
                    everything from the whole text together into a program 
                    that's truly my own, where I took it as a problem 
                    statement to create a solution for rather than as a 
                    LeetCode-esque exercise to figure out an abstract 
                    algorithm. I now have an extensible application that works 
                    as my own custom & quickly searchable file manager, and 
                    it's thanks to the application requested by this book. 
                    With some polish, it can even become something you can 
                    sell to people, and that crosses a line from being a 
                    textbook exercise to being a peek into the vision of an 
                    engineer, the vision of the one who wrote this book.
                </p>

                <p>
                    I have my own visions, too: problems to solve and 
                    solutions to be made. And with this book now behind me, 
                    I'm definitively better prepared for that future.
                </p>
            </details>
        </main>

        
        <!-- 
            
            BOOK EXERCISE SCRIPTS

        -->

        <script src="chapter-2-exercises.js"></script>

        <script src="chapter-3-exercises.js"></script>

        <script src="chapter-4-exercises.js"></script>

        <script src="chapter-5-exercises.js"></script>

        <script src="chapter-6-exercises.js"></script>

        <script src="chapter-7-exercises.js"></script>

        <!-- 
            Chapter 8 exercises run based on code embedded in the textbook 
            site, if not inputs that are functions. Function inputs as UI 
            elements put full control of the page onto the UI, which I don't 
            want for this page.
        -->

        <script src="chapter-9-exercises.js"></script>

        <script title="Chapter 10 Exercise 2" type="module">
            import graph from "./chapter-10-exercises-road-graph.js";

            console.log('CHAPTER 10 EXERCISE 2 OUTPUT IS BELOW');
            console.log(graph);
            console.log('CHAPTER 10 EXERCISE 2 OUTPUT IS ABOVE');
        </script>


        <!--
            I did little Leetcode Java during this, too, just as sanity checks 
            to make sure I don't lose that as I regain JavaScript specifics 
            that are similar-sounding. If switching back & forth between 
            those two, it might be easy to get wires crossed between my mental 
            models of their coding patterns.

            Here's a Java solution I noodled out for Leetcode problem 139 in 
            a couple of minutes:

            public boolean wordBreak(String s, List<String> wordDict) {
                for(int i = 0; i < wordDict.size(); i++) {
                    if(wordBreaks(s, wordDict.get(i), wordDict)) {
                        return true;
                    }
                }
                
                return false;
            }

            public boolean wordBreaks(String s, String dictionaryWord, List<String> wordDict) {
                return s.startsWith(dictionaryWord) && subWordBreaks(s.substring(dictionaryWord.length()), wordDict);
            }

            public boolean subWordBreaks(String subWord, List<String> wordDict) {
                return subWord.length() == 0 || wordBreak(subWord, wordDict);
            }

            Sanity checked.
        -->
    </body>
</html>
